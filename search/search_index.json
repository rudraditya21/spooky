{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#spooky-documentation","title":"Spooky Documentation","text":"<p>Technical documentation for the Spooky HTTP/3 to HTTP/2 reverse proxy and load balancer.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Overview - Project introduction and capabilities</li> <li>Installation - System requirements and installation procedures</li> <li>Quick Start Tutorial - Step-by-step guide to get running</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Configuration Reference - Complete configuration documentation</li> <li>TLS Setup - Certificate generation and management</li> </ul>"},{"location":"#user-guides","title":"User Guides","text":"<ul> <li>Basic Usage - Core concepts and usage patterns</li> <li>Load Balancing - Load balancing algorithms and health checks</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<ul> <li>Architecture Overview - System design and component interaction</li> <li>Component Details - High-level architectural principles</li> <li>Component Breakdown - Detailed crate documentation</li> </ul>"},{"location":"#deployment","title":"Deployment","text":"<ul> <li>Production Deployment - Production deployment guide</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Contributing Guide - Development setup and guidelines</li> </ul>"},{"location":"#protocol-reference","title":"Protocol Reference","text":"<ul> <li>HTTP/3 Protocol - HTTP/3 overview and implementation</li> <li>QUIC Protocol - QUIC fundamentals and usage</li> </ul>"},{"location":"#api-and-observability","title":"API and Observability","text":"<ul> <li>API Overview - Metrics, logging, and future admin API</li> </ul>"},{"location":"#planning","title":"Planning","text":"<ul> <li>Roadmap - Feature roadmap and priorities</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 README.md                      # This file\n\u251c\u2500\u2500 architecture.md                # Main architecture document\n\u251c\u2500\u2500 roadmap.md                     # Project roadmap\n\u2502\n\u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 overview.md                # Project overview\n\u2502   \u2514\u2500\u2500 installation.md            # Installation guide\n\u2502\n\u251c\u2500\u2500 configuration/\n\u2502   \u251c\u2500\u2500 reference.md               # Configuration reference\n\u2502   \u2514\u2500\u2500 tls.md                     # TLS setup\n\u2502\n\u251c\u2500\u2500 user-guide/\n\u2502   \u251c\u2500\u2500 basics.md                  # Basic usage\n\u2502   \u2514\u2500\u2500 load-balancing.md          # Load balancing guide\n\u2502\n\u251c\u2500\u2500 architecture/\n\u2502   \u251c\u2500\u2500 overview.md                # Architecture overview\n\u2502   \u2514\u2500\u2500 components.md              # Component details\n\u2502\n\u251c\u2500\u2500 deployment/\n\u2502   \u2514\u2500\u2500 production.md              # Production deployment\n\u2502\n\u251c\u2500\u2500 troubleshooting/\n\u2502   \u2514\u2500\u2500 common-issues.md           # Troubleshooting guide\n\u2502\n\u251c\u2500\u2500 development/\n\u2502   \u2514\u2500\u2500 contributing.md            # Contributing guide\n\u2502\n\u251c\u2500\u2500 tutorials/\n\u2502   \u2514\u2500\u2500 quickstart.md              # Quick start tutorial\n\u2502\n\u251c\u2500\u2500 protocols/\n\u2502   \u251c\u2500\u2500 http3.md                   # HTTP/3 protocol\n\u2502   \u2514\u2500\u2500 quic.md                    # QUIC protocol\n\u2502\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 overview.md                # API documentation\n\u2502\n\u2514\u2500\u2500 internal/                      # Internal documentation\n    \u2514\u2500\u2500 spooky.md                  # Internal architecture notes\n</code></pre>"},{"location":"#quick-references","title":"Quick References","text":""},{"location":"#common-configuration-tasks","title":"Common Configuration Tasks","text":"<p>Basic upstream pool: </p><pre><code>upstream:\n  backend:\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"backend-1\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre><p></p> <p>Note: Load balancing strategy is configured globally, not per upstream.</p> <p>Path-based routing: </p><pre><code>upstream:\n  api:\n    route:\n      path_prefix: \"/api\"\n    # ... backends\n\n  web:\n    route:\n      path_prefix: \"/\"\n    # ... backends\n</code></pre><p></p> <p>Load balancing algorithms: - <code>random</code> - Random selection - <code>round-robin</code> - Sequential rotation - <code>consistent-hash</code> - Hash-based affinity</p>"},{"location":"#common-commands","title":"Common Commands","text":"<p>Start Spooky: </p><pre><code>spooky --config /etc/spooky/config.yaml\n</code></pre><p></p> <p>Test HTTP/3 connection: </p><pre><code>curl --http3-only -k \\\n  --resolve proxy.example.com:9889:127.0.0.1 \\\n  https://proxy.example.com:9889/health\n</code></pre><p></p> <p>Check configuration: </p><pre><code>spooky --config config.yaml  # Starts serving after validation\n</code></pre><p></p> <p>View logs: </p><pre><code># All logs\nRUST_LOG=info spooky --config config.yaml\n\n# Debug QUIC only\nRUST_LOG=spooky_edge=debug spooky --config config.yaml\n\n# Trace everything\nRUST_LOG=trace spooky --config config.yaml\n</code></pre><p></p>"},{"location":"#documentation-guidelines","title":"Documentation Guidelines","text":"<p>This documentation follows these principles:</p> <ol> <li>Technical Accuracy: All examples are based on the actual codebase</li> <li>Honest Status: Capabilities and limitations are documented as-is</li> <li>Direct Communication: Clear, concise technical writing</li> <li>Complete Coverage: All configuration options documented</li> <li>Practical Examples: Working code and configuration samples</li> </ol>"},{"location":"#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>To improve documentation:</p> <ol> <li>Check accuracy against source code</li> <li>Test all examples and commands</li> <li>Use clear, technical language</li> <li>Include practical examples</li> <li>Update this index when adding new docs</li> </ol> <p>See Contributing Guide for more details.</p>"},{"location":"#external-resources","title":"External Resources","text":"<ul> <li>QUIC RFC 9000</li> <li>HTTP/3 RFC 9114</li> <li>quiche Documentation</li> <li>Rust Documentation</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Review troubleshooting guide: docs/troubleshooting/common-issues.md</li> <li>Check GitHub issues for community discussions</li> <li>Read protocol documentation for HTTP/3 and QUIC specifics</li> </ul>"},{"location":"#license","title":"License","text":"<p>Elastic License 2.0 (ELv2) - see LICENSE for details.</p>"},{"location":"architecture/","title":"Overview","text":""},{"location":"architecture/#architecture","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>Spooky is a reverse proxy that terminates HTTP/3/QUIC connections and forwards requests to HTTP/2 backends. The architecture prioritizes correctness, observability, and operational simplicity.</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Protocol Isolation: QUIC termination is separate from HTTP/2 backend communication</li> <li>Fail Fast: Configuration errors are caught at startup, not during runtime</li> <li>Health-Aware Routing: Backend selection considers health state</li> <li>Observability First: All state transitions and errors are logged</li> </ol>"},{"location":"architecture/#component-architecture","title":"Component Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Spooky Process                       \u2502\n\u2502                                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502               Main Event Loop                       \u2502 \u2502\n\u2502  \u2502  (Synchronous UDP polling with timeout)            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502           QUIC Listener (crates/edge)              \u2502 \u2502\n\u2502  \u2502  - UDP socket management                           \u2502 \u2502\n\u2502  \u2502  - quiche connection handling                      \u2502 \u2502\n\u2502  \u2502  - Connection ID routing                           \u2502 \u2502\n\u2502  \u2502  - HTTP/3 stream multiplexing                      \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502         Router (find_upstream_for_request)         \u2502 \u2502\n\u2502  \u2502  - Path prefix matching                            \u2502 \u2502\n\u2502  \u2502  - Host header matching                            \u2502 \u2502\n\u2502  \u2502  - Longest match selection                         \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502    Load Balancer (crates/lb)                       \u2502 \u2502\n\u2502  \u2502  - Backend selection algorithms                    \u2502 \u2502\n\u2502  \u2502  - Health state filtering                          \u2502 \u2502\n\u2502  \u2502  - Per-upstream strategy                           \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502    Protocol Bridge (crates/bridge)                 \u2502 \u2502\n\u2502  \u2502  - HTTP/3 to HTTP/2 header conversion             \u2502 \u2502\n\u2502  \u2502  - Body buffering                                  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502    HTTP/2 Pool (crates/transport)                  \u2502 \u2502\n\u2502  \u2502  - Backend connection pooling                      \u2502 \u2502\n\u2502  \u2502  - Request forwarding                              \u2502 \u2502\n\u2502  \u2502  - Concurrency limiting                            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502    Health Checker (async tasks)                    \u2502 \u2502\n\u2502  \u2502  - Periodic HTTP probes                            \u2502 \u2502\n\u2502  \u2502  - Backend state tracking                          \u2502 \u2502\n\u2502  \u2502  - Health transition logging                       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#request-flow","title":"Request Flow","text":""},{"location":"architecture/#1-connection-establishment","title":"1. Connection Establishment","text":"<pre><code>Client                  Spooky                    Backend\n  \u2502                       \u2502                          \u2502\n  \u251c\u2500 QUIC Initial \u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                          \u2502\n  \u2502                       \u2502                          \u2502\n  \u2502&lt;\u2500\u2500\u2500\u2500\u2500 ServerHello \u2500\u2500\u2500\u2500\u2524                          \u2502\n  \u2502                       \u2502                          \u2502\n  \u251c\u2500 Handshake \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                          \u2502\n  \u2502                       \u2502                          \u2502\n  \u2502&lt;\u2500\u2500\u2500\u2500\u2500 Handshake \u2500\u2500\u2500\u2500\u2500\u2500\u2524                          \u2502\n  \u2502                       \u2502                          \u2502\n  \u2502    [Connection ID routing established]          \u2502\n</code></pre> <p>Key Points: - Server generates 16-byte SCID for each connection - Connection stored by SCID for subsequent packet routing - Prefix matching handles clients that extend DCID - Peer-based fallback for connection migration</p>"},{"location":"architecture/#2-http3-request-processing","title":"2. HTTP/3 Request Processing","text":"<pre><code>  \u2502                       \u2502                          \u2502\n  \u251c\u2500 HEADERS frame \u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                          \u2502\n  \u251c\u2500 DATA frame \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                          \u2502\n  \u2502                       \u2502                          \u2502\n  \u2502                       \u251c\u2500 Route matching          \u2502\n  \u2502                       \u251c\u2500 Upstream selection      \u2502\n  \u2502                       \u251c\u2500 Backend selection       \u2502\n  \u2502                       \u2502                          \u2502\n  \u2502                       \u251c\u2500 HTTP/2 request \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                       \u2502                          \u2502\n  \u2502                       \u2502&lt;\u2500\u2500\u2500\u2500 HTTP/2 response \u2500\u2500\u2500\u2500\u2524\n  \u2502                       \u2502                          \u2502\n  \u2502&lt;\u2500\u2500 HEADERS frame \u2500\u2500\u2500\u2500\u2500\u2524                          \u2502\n  \u2502&lt;\u2500\u2500 DATA frame \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                          \u2502\n</code></pre> <p>Processing Steps:</p> <ol> <li>Stream Reception: HTTP/3 frames decoded via quiche</li> <li>Request Envelope: Headers, path, authority, and body buffered</li> <li>Route Matching: Find upstream with longest matching path prefix</li> <li>Load Balancing: Select healthy backend from upstream pool</li> <li>Protocol Bridge: Convert HTTP/3 request to HTTP/2</li> <li>Backend Call: Forward via connection pool with timeout</li> <li>Response Streaming: Convert HTTP/2 response to HTTP/3</li> </ol>"},{"location":"architecture/#3-route-matching-algorithm","title":"3. Route Matching Algorithm","text":"<pre><code>fn find_upstream_for_request(\n    upstreams: HashMap&lt;String, Upstream&gt;,\n    path: &amp;str,\n    host: Option&lt;&amp;str&gt;\n) -&gt; Option&lt;String&gt; {\n    let mut best_match = None;\n    let mut best_length = 0;\n\n    for (name, upstream) in upstreams {\n        // Check host match\n        if let Some(required_host) = upstream.route.host {\n            if host != Some(required_host) {\n                continue;\n            }\n        }\n\n        // Check path prefix match\n        if let Some(prefix) = upstream.route.path_prefix {\n            if path.starts_with(prefix) &amp;&amp; prefix.len() &gt; best_length {\n                best_match = Some(name);\n                best_length = prefix.len();\n            }\n        }\n    }\n\n    best_match\n}\n</code></pre> <p>Example: - Request: <code>/api/users/123</code> - Routes: <code>/</code> (length 1), <code>/api</code> (length 4) - Selected: <code>/api</code> (longest match)</p>"},{"location":"architecture/#connection-management","title":"Connection Management","text":""},{"location":"architecture/#connection-id-routing","title":"Connection ID Routing","text":"<p>Spooky uses a connection ID-based routing scheme to multiplex multiple QUIC connections:</p> <ol> <li>Initial Packet: Client sends with random DCID</li> <li>Server Response: Generates 16-byte SCID, stores connection</li> <li>Subsequent Packets: Client uses server SCID as DCID</li> <li>Lookup: HashMap lookup by DCID finds connection</li> </ol> <p>Special Cases: - Prefix Match: Client extends DCID (e.g., 20 bytes) \u2192 match by prefix - Peer Fallback: DCID not found \u2192 search by peer address - Version Negotiation: Unsupported version \u2192 send version negotiation packet</p>"},{"location":"architecture/#connection-lifecycle","title":"Connection Lifecycle","text":"<pre><code>[Initial Packet] \u2192 [Handshake] \u2192 [Established] \u2192 [Active] \u2192 [Draining] \u2192 [Closed]\n       \u2502                                \u2502            \u2502           \u2502\n       \u25bc                                \u25bc            \u25bc           \u25bc\n  Accept &amp; SCID                   HTTP/3 Streams  Shutdown  Cleanup\n  Generation                                       Signal\n</code></pre>"},{"location":"architecture/#load-balancing","title":"Load Balancing","text":""},{"location":"architecture/#backend-selection","title":"Backend Selection","text":"<p>Each upstream pool maintains its own backend list with health state:</p> <pre><code>struct BackendState {\n    address: String,\n    weight: u32,\n    health_state: HealthState,\n    consecutive_failures: u32,\n}\n\nenum HealthState {\n    Healthy,\n    Unhealthy {\n        until: Instant,      // Cooldown expiry\n        successes: u32,      // Success count during recovery\n    },\n}\n</code></pre>"},{"location":"architecture/#algorithms","title":"Algorithms","text":"<p>Random: </p><pre><code>candidates = healthy_backends()\nindex = random(0, candidates.len())\nreturn candidates[index]\n</code></pre><p></p> <p>Round Robin: </p><pre><code>candidates = healthy_backends()\nindex = (next_counter % candidates.len())\nnext_counter += 1\nreturn candidates[index]\n</code></pre><p></p> <p>Consistent Hash: </p><pre><code>ring = build_ring(backends, replicas=64)\nkey_hash = hash(request_key)\nposition = ring.find_next(key_hash)\nreturn backends[position]\n</code></pre><p></p>"},{"location":"architecture/#health-checking","title":"Health Checking","text":"<p>Each backend has an independent health checker that:</p> <ol> <li>Issues periodic HTTP GET to configured path</li> <li>Evaluates response status (2xx = healthy)</li> <li>Updates backend state on success/failure</li> <li>Applies threshold-based state transitions</li> </ol> <p>State Transitions: </p><pre><code>Healthy \u2500[failure_threshold fails]\u2500&gt; Unhealthy\nUnhealthy \u2500[cooldown expires + success_threshold succeeds]\u2500&gt; Healthy\n</code></pre><p></p>"},{"location":"architecture/#data-structures","title":"Data Structures","text":""},{"location":"architecture/#quiclistener","title":"QUICListener","text":"<pre><code>pub struct QUICListener {\n    socket: UdpSocket,\n    quic_config: quiche::Config,\n    h3_config: Arc&lt;quiche::h3::Config&gt;,\n    connections: HashMap&lt;Vec&lt;u8&gt;, QuicConnection&gt;,  // Key: SCID\n    upstream_pools: HashMap&lt;String, Arc&lt;Mutex&lt;UpstreamPool&gt;&gt;&gt;,\n    h2_pool: Arc&lt;H2Pool&gt;,\n    metrics: Metrics,\n    // ...\n}\n</code></pre>"},{"location":"architecture/#quicconnection","title":"QuicConnection","text":"<pre><code>pub struct QuicConnection {\n    quic: quiche::Connection,\n    h3: Option&lt;quiche::h3::Connection&gt;,\n    streams: HashMap&lt;u64, RequestEnvelope&gt;,\n    peer_address: SocketAddr,\n    last_activity: Instant,\n}\n</code></pre>"},{"location":"architecture/#upstreampool","title":"UpstreamPool","text":"<pre><code>pub struct UpstreamPool {\n    pool: BackendPool,      // Backend list with health state\n    strategy: String,       // Load balancing algorithm name\n}\n</code></pre>"},{"location":"architecture/#concurrency-model","title":"Concurrency Model","text":""},{"location":"architecture/#main-thread-synchronous","title":"Main Thread (Synchronous)","text":"<ul> <li>UDP socket polling with 50ms timeout</li> <li>QUIC packet processing via quiche</li> <li>HTTP/3 stream handling</li> <li>Route matching and backend selection</li> <li>Synchronous backend calls via <code>run_blocking</code></li> </ul>"},{"location":"architecture/#async-tasks-tokio-runtime","title":"Async Tasks (Tokio Runtime)","text":"<ul> <li>Health check probes (one task per backend)</li> <li>Shutdown signal handling</li> </ul>"},{"location":"architecture/#blocking-operations","title":"Blocking Operations","text":"<p>Backend forwarding temporarily enters Tokio runtime:</p> <pre><code>fn run_blocking&lt;F, T&gt;(f: F) -&gt; Result&lt;T&gt;\nwhere\n    F: FnOnce() -&gt; Future&lt;Output = T&gt;,\n{\n    if let Ok(handle) = Handle::try_current() {\n        // Within Tokio context\n        tokio::task::block_in_place(|| handle.block_on(f()))\n    } else {\n        // Outside Tokio context\n        let rt = Runtime::new()?;\n        rt.block_on(f())\n    }\n}\n</code></pre>"},{"location":"architecture/#configuration-system","title":"Configuration System","text":""},{"location":"architecture/#validation-pipeline","title":"Validation Pipeline","text":"<pre><code>YAML file \u2192 Parse \u2192 Validate \u2192 Build runtime structures\n              \u2502         \u2502              \u2502\n              \u25bc         \u25bc              \u25bc\n         serde::de   Validator    QUICListener::new\n                                  UpstreamPool::from_upstream\n                                  LoadBalancing::from_config\n</code></pre>"},{"location":"architecture/#validation-checks","title":"Validation Checks","text":"<ul> <li>TLS certificate and key files exist and are readable</li> <li>Listen port in valid range (1-65535)</li> <li>All backend addresses are parseable</li> <li>Load balancing types are supported</li> <li>Health check intervals are non-zero</li> <li>Route patterns are valid</li> </ul>"},{"location":"architecture/#error-handling","title":"Error Handling","text":""},{"location":"architecture/#request-level-errors","title":"Request-Level Errors","text":"Error Source HTTP Status Action Invalid request 400 Return error to client No healthy backends 503 Return error to client Backend timeout 503 Mark backend failure, return error Backend connection error 502 Mark backend failure, return error Backend 5xx response Pass through Mark backend failure"},{"location":"architecture/#connection-level-errors","title":"Connection-Level Errors","text":"Error Type Action QUIC crypto failure Log and close connection QUIC protocol violation Log and close connection HTTP/3 stream error Reset stream, keep connection Idle timeout Close connection"},{"location":"architecture/#system-level-errors","title":"System-Level Errors","text":"Error Type Action Config validation failure Exit on startup TLS load failure Exit on startup Socket bind failure Exit on startup Health check task panic Log error, continue"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/#memory-usage","title":"Memory Usage","text":"<ul> <li>Base process: ~50MB</li> <li>Per connection: ~1-2KB</li> <li>Per stream: ~500B</li> <li>Buffer sizes: 64KB (configurable)</li> </ul>"},{"location":"architecture/#cpu-usage","title":"CPU Usage","text":"<ul> <li>Packet processing: Minimal (quiche handles crypto)</li> <li>Route matching: O(N) where N = upstream count</li> <li>Load balancing: O(1) for random/round-robin, O(log M) for consistent hash where M = backend count</li> <li>Health checking: Periodic, minimal impact</li> </ul>"},{"location":"architecture/#bottlenecks","title":"Bottlenecks","text":"<p>Current architectural bottlenecks:</p> <ol> <li>Synchronous backend calls: Block main thread during HTTP/2 roundtrip</li> <li>Full body buffering: Materializes entire request/response in memory</li> <li>Consistent hash ring: Rebuilds on every request</li> <li>Single-threaded poll loop: All QUIC processing on one thread</li> </ol> <p>See roadmap for planned improvements.</p>"},{"location":"architecture/#security","title":"Security","text":""},{"location":"architecture/#tls-configuration","title":"TLS Configuration","text":"<ul> <li>TLS 1.3 only (via quiche)</li> <li>ALPN: h3 (HTTP/3)</li> <li>Peer verification disabled (development mode)</li> <li>Certificate chain loaded from PEM files</li> </ul>"},{"location":"architecture/#attack-mitigation","title":"Attack Mitigation","text":"<p>Current protections:</p> <ul> <li>Connection ID randomization</li> <li>Idle timeout enforcement</li> <li>Buffer size limits</li> <li>Health check prevents amplification to backends</li> </ul> <p>Missing protections (planned):</p> <ul> <li>Rate limiting per client IP</li> <li>Request size limits</li> <li>DDoS protection</li> <li>TLS peer verification</li> </ul>"},{"location":"architecture/#observability","title":"Observability","text":""},{"location":"architecture/#logging","title":"Logging","text":"<p>Structured logging at multiple levels:</p> <ul> <li>Error: Critical failures, backend errors</li> <li>Warn: Backend health transitions, timeouts</li> <li>Info: Request processing, backend selection</li> <li>Debug: QUIC packet handling, connection state</li> <li>Trace: Detailed protocol messages</li> </ul>"},{"location":"architecture/#metrics","title":"Metrics","text":"<p>Current metrics (AtomicU64):</p> <ul> <li><code>requests_total</code>: Total requests received</li> <li><code>requests_success</code>: Successfully forwarded requests</li> <li><code>requests_failure</code>: Failed requests</li> <li><code>backend_timeouts</code>: Backend timeout count</li> <li><code>backend_errors</code>: Backend error count</li> </ul> <p>No metrics exporter currently implemented.</p>"},{"location":"architecture/#debugging","title":"Debugging","text":"<p>Connection state logging:</p> <pre><code>debug!(\"Packet DCID (len={}): {:02x?}, type: {:?}, active connections: {}\",\n    dcid_bytes.len(), &amp;dcid_bytes, header.ty, self.connections.len());\n</code></pre> <p>Backend selection logging:</p> <pre><code>info!(\"Selected backend {} via {}\", backend_addr, lb_name(load_balancer));\n</code></pre> <p>Health transition logging:</p> <pre><code>info!(\"Backend {} became unhealthy\", addr);\n</code></pre>"},{"location":"architecture/#future-directions","title":"Future Directions","text":"<p>See roadmap for planned architectural improvements:</p> <ul> <li>Async data plane</li> <li>Streaming request/response bodies</li> <li>Multi-threaded QUIC handling</li> <li>Metrics export</li> <li>Configuration hot reload</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"references/","title":"References","text":""},{"location":"references/#references","title":"References","text":"<p>Technical references and external resources for Spooky development.</p>"},{"location":"references/#protocol-specifications","title":"Protocol Specifications","text":""},{"location":"references/#quic-and-http3","title":"QUIC and HTTP/3","text":"<ul> <li>RFC 9000 - QUIC: A UDP-Based Multiplexed and Secure Transport</li> <li>RFC 9001 - Using TLS to Secure QUIC</li> <li>RFC 9002 - QUIC Loss Detection and Congestion Control</li> <li>RFC 9114 - HTTP/3</li> <li>RFC 9204 - QPACK: Field Compression for HTTP/3</li> </ul>"},{"location":"references/#http2","title":"HTTP/2","text":"<ul> <li>RFC 9113 - HTTP/2</li> <li>RFC 7541 - HPACK: Header Compression for HTTP/2</li> </ul>"},{"location":"references/#tls","title":"TLS","text":"<ul> <li>RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3</li> <li>RFC 7301 - Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</li> </ul>"},{"location":"references/#core-dependencies","title":"Core Dependencies","text":""},{"location":"references/#quic-and-http3_1","title":"QUIC and HTTP/3","text":"<ul> <li>quiche - Cloudflare's QUIC and HTTP/3 implementation</li> <li>quinn - Alternative async QUIC implementation</li> </ul>"},{"location":"references/#http2_1","title":"HTTP/2","text":"<ul> <li>hyper - HTTP client and server library</li> <li>h2 - HTTP/2 implementation</li> </ul>"},{"location":"references/#async-runtime","title":"Async Runtime","text":"<ul> <li>tokio - Asynchronous runtime for Rust</li> <li>futures - Async utilities</li> </ul>"},{"location":"references/#serialization","title":"Serialization","text":"<ul> <li>serde - Serialization framework</li> <li>serde_yaml - YAML support for serde</li> </ul>"},{"location":"references/#cli-and-configuration","title":"CLI and Configuration","text":"<ul> <li>clap - Command-line argument parser</li> </ul>"},{"location":"references/#utilities","title":"Utilities","text":"<ul> <li>bytes - Efficient byte buffer types</li> <li>http - HTTP types</li> <li>log - Logging facade</li> <li>env_logger - Logger implementation</li> <li>rand - Random number generation</li> </ul>"},{"location":"references/#tls_1","title":"TLS","text":"<ul> <li>rustls - Modern TLS library</li> <li>rustls-pki-types - TLS certificate types</li> </ul>"},{"location":"references/#load-balancing-resources","title":"Load Balancing Resources","text":""},{"location":"references/#algorithms","title":"Algorithms","text":"<ul> <li>Consistent Hashing and Random Trees - Original consistent hashing paper</li> <li>The Power of Two Random Choices - Random selection strategy analysis</li> </ul>"},{"location":"references/#health-checking","title":"Health Checking","text":"<ul> <li>Circuit Breaker Pattern - Martin Fowler</li> <li>Health Checks for gRPC - gRPC health check protocol</li> </ul>"},{"location":"references/#performance-and-optimization","title":"Performance and Optimization","text":""},{"location":"references/#quic-performance","title":"QUIC Performance","text":"<ul> <li>QUIC at Cloudflare - Production QUIC deployment insights</li> <li>QUIC at Google - Chrome QUIC implementation notes</li> </ul>"},{"location":"references/#http3-optimization","title":"HTTP/3 Optimization","text":"<ul> <li>HTTP/3 Explained - Daniel Stenberg's HTTP/3 guide</li> <li>HTTP/3 Performance - Real-world performance analysis</li> </ul>"},{"location":"references/#system-tuning","title":"System Tuning","text":"<ul> <li>Linux Network Stack - Kernel networking documentation</li> <li>UDP Performance - High-performance UDP handling</li> </ul>"},{"location":"references/#security","title":"Security","text":""},{"location":"references/#tls-best-practices","title":"TLS Best Practices","text":"<ul> <li>Mozilla SSL Configuration Generator - TLS configuration recommendations</li> <li>Certificate Transparency - CT log monitoring</li> </ul>"},{"location":"references/#quic-security","title":"QUIC Security","text":"<ul> <li>QUIC Crypto - QUIC cryptographic design</li> <li>QUIC Security Considerations - RFC 9000 Section 21</li> </ul>"},{"location":"references/#testing-and-debugging","title":"Testing and Debugging","text":""},{"location":"references/#tools","title":"Tools","text":"<ul> <li>curl with HTTP/3 - Testing HTTP/3 endpoints</li> <li>h3i - Interactive HTTP/3 client</li> <li>Wireshark QUIC - Packet capture and analysis</li> </ul>"},{"location":"references/#load-testing","title":"Load Testing","text":"<ul> <li>h2load - HTTP/2 load testing tool</li> <li>wrk2 - HTTP benchmarking tool</li> </ul>"},{"location":"references/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"references/#metrics","title":"Metrics","text":"<ul> <li>Prometheus Documentation - Metrics collection</li> <li>OpenTelemetry - Observability framework</li> </ul>"},{"location":"references/#tracing","title":"Tracing","text":"<ul> <li>Tokio Tracing - Application-level tracing</li> <li>Jaeger - Distributed tracing</li> </ul>"},{"location":"references/#related-projects","title":"Related Projects","text":""},{"location":"references/#http3-proxies","title":"HTTP/3 Proxies","text":"<ul> <li>nghttpx - HTTP/2 and HTTP/3 proxy</li> <li>h2o - HTTP/1.x, HTTP/2, HTTP/3 server</li> </ul>"},{"location":"references/#quic-implementations","title":"QUIC Implementations","text":"<ul> <li>quic-go - Go QUIC implementation</li> <li>msquic - Microsoft QUIC implementation</li> <li>ngtcp2 - C QUIC library</li> </ul>"},{"location":"references/#load-balancers","title":"Load Balancers","text":"<ul> <li>HAProxy - Traditional TCP/HTTP load balancer</li> <li>Envoy - Modern L7 proxy and load balancer</li> <li>Traefik - Cloud-native edge router</li> </ul>"},{"location":"references/#community-resources","title":"Community Resources","text":""},{"location":"references/#rust","title":"Rust","text":"<ul> <li>Rust Programming Language Book</li> <li>Rust Async Book</li> <li>Tokio Tutorial</li> </ul>"},{"location":"references/#quic-and-http3_2","title":"QUIC and HTTP/3","text":"<ul> <li>QUIC Working Group - IETF QUIC standardization</li> <li>HTTP/3 Implementations - List of QUIC/HTTP3 implementations</li> </ul>"},{"location":"references/#academic-papers","title":"Academic Papers","text":"<ul> <li>QUIC: A UDP-Based Multiplexed and Secure Transport - SIGCOMM 2017</li> <li>The QUIC Transport Protocol: Design and Internet-Scale Deployment - SIGCOMM 2017</li> <li>An Analysis of QUIC in the Wild - IMC 2019</li> </ul>"},{"location":"references/#contributing","title":"Contributing","text":"<p>To add a reference:</p> <ol> <li>Verify the resource is authoritative and current</li> <li>Add to the appropriate section</li> <li>Include a brief description</li> <li>Test all links</li> </ol> <p>See contributing guide for more details.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":""},{"location":"roadmap/#current-status","title":"Current Status","text":"<p>Experimental. Core features functional and tested. Spooky can terminate HTTP/3 connections, forward to HTTP/2 backends, and perform load balancing with health checks. It is not production-ready \u2014 significant known limitations exist (see Technical Debt below).</p>"},{"location":"roadmap/#completed","title":"Completed","text":"<ul> <li>HTTP/3 termination via quiche</li> <li>HTTP/2 backend connectivity</li> <li>Path and host-based routing</li> <li>Multiple load balancing algorithms (random, round-robin, consistent hash)</li> <li>Active health checking with automatic backend management</li> <li>Per-upstream configuration and routing</li> <li>Connection ID management and QUIC packet routing</li> <li>TLS 1.3 with certificate chain loading</li> <li>Structured logging with multiple levels</li> <li>Configuration validation at startup</li> <li>Graceful shutdown with connection draining</li> </ul>"},{"location":"roadmap/#phase-1-operational-hardening","title":"Phase 1: Operational Hardening","text":"<p>Goal: Expand operational and scalability capabilities for production deployments.</p>"},{"location":"roadmap/#performance","title":"Performance","text":"<ul> <li>Async data plane: Move backend forwarding off the main poll thread</li> <li>Streaming bodies: Implement incremental request/response streaming instead of full buffering</li> <li>Multi-threading: Support multi-threaded QUIC packet processing</li> <li>Connection pooling optimizations: Reduce allocation overhead in HTTP/2 pool</li> </ul>"},{"location":"roadmap/#observability","title":"Observability","text":"<ul> <li>Metrics export: Prometheus endpoint for scraping metrics</li> <li>Distributed tracing: OpenTelemetry integration</li> <li>Request logging: Per-request structured logs with correlation IDs</li> <li>Connection metrics: Track QUIC RTT, packet loss, stream count</li> </ul>"},{"location":"roadmap/#operational","title":"Operational","text":"<ul> <li>Configuration hot reload: Reload config on SIGHUP without dropping connections</li> <li>Health check improvements: Separate client pool for probes to avoid contention</li> <li>TLS certificate reload: Automatic reload on certificate rotation</li> <li>Admin API: HTTP endpoint for runtime statistics and control</li> </ul>"},{"location":"roadmap/#reliability","title":"Reliability","text":"<ul> <li>Circuit breaker: Per-backend circuit breakers to prevent cascading failures</li> <li>Retry logic: Configurable request retry with exponential backoff</li> <li>Request timeouts: Per-route timeout configuration</li> <li>Rate limiting: Per-IP and per-route rate limits</li> </ul>"},{"location":"roadmap/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Goal: Add advanced traffic management and operational capabilities.</p>"},{"location":"roadmap/#traffic-management","title":"Traffic Management","text":"<ul> <li>Weighted routing: Route percentage of traffic to different upstreams</li> <li>Header-based routing: Route by arbitrary request headers</li> <li>Request rewriting: URL rewriting and header manipulation</li> <li>Compression: Automatic response compression</li> </ul>"},{"location":"roadmap/#load-balancing","title":"Load Balancing","text":"<ul> <li>Least connections: Track active connections per backend</li> <li>Response time: Route based on backend latency</li> <li>Weighted least connection: Combine weights with connection count</li> <li>Cached consistent hash: Cache hash ring to avoid rebuilds</li> </ul>"},{"location":"roadmap/#security","title":"Security","text":"<ul> <li>TLS peer verification: Enable certificate verification for production</li> <li>mTLS support: Client certificate authentication</li> <li>Request validation: Size limits, header validation</li> <li>IP allowlist/blocklist: Simple access control</li> </ul>"},{"location":"roadmap/#deployment","title":"Deployment","text":"<ul> <li>Dynamic backend discovery: Service discovery integration (DNS SRV, Consul, etcd)</li> <li>Backend metadata: Tags and labels for flexible routing</li> <li>A/B testing support: Route subset of traffic to experimental backends</li> <li>Canary deployments: Gradually shift traffic to new backend versions</li> </ul>"},{"location":"roadmap/#phase-3-enterprise-features","title":"Phase 3: Enterprise Features","text":"<p>Goal: Support large-scale deployments with advanced requirements.</p>"},{"location":"roadmap/#multi-tenancy","title":"Multi-Tenancy","text":"<ul> <li>Namespace isolation: Separate routing tables per tenant</li> <li>Resource limits: Per-tenant connection and request limits</li> <li>Tenant routing: Route by tenant ID or subdomain</li> </ul>"},{"location":"roadmap/#advanced-observability","title":"Advanced Observability","text":"<ul> <li>APM integration: Datadog, New Relic, etc.</li> <li>Custom metrics: User-defined metric collection</li> <li>Traffic replay: Record and replay production traffic</li> <li>Query logs: SQL-like queries over request logs</li> </ul>"},{"location":"roadmap/#extensions","title":"Extensions","text":"<ul> <li>WebAssembly plugins: Custom routing logic via WASM</li> <li>Lua scripting: Dynamic request/response transformation</li> <li>gRPC support: Native gRPC proxying</li> <li>WebSocket support: WebSocket over HTTP/3</li> </ul>"},{"location":"roadmap/#high-availability","title":"High Availability","text":"<ul> <li>Connection migration: Support QUIC connection migration</li> <li>State replication: Share connection state across instances</li> <li>Zero-downtime updates: Binary updates without connection loss</li> <li>Multi-region support: Geographic routing and failover</li> </ul>"},{"location":"roadmap/#phase-4-protocol-extensions","title":"Phase 4: Protocol Extensions","text":"<p>Goal: Support emerging protocols and optimizations.</p>"},{"location":"roadmap/#http3-features","title":"HTTP/3 Features","text":"<ul> <li>0-RTT support: Enable 0-RTT with proper anti-replay measures</li> <li>QUIC multipath: Support multiple network paths</li> <li>Datagram support: QUIC DATAGRAM frames for low-latency data</li> <li>Priority trees: HTTP/3 priority and scheduling</li> </ul>"},{"location":"roadmap/#additional-protocols","title":"Additional Protocols","text":"<ul> <li>HTTP/1.1 support: Serve HTTP/1.1 clients</li> <li>TCP proxy mode: Layer 4 TCP proxying</li> <li>UDP proxy: Forward UDP traffic</li> <li>MQTT support: IoT protocol support</li> </ul>"},{"location":"roadmap/#optimizations","title":"Optimizations","text":"<ul> <li>Zero-copy: Eliminate unnecessary data copies</li> <li>Kernel bypass: AF_XDP or DPDK integration</li> <li>Hardware offload: TLS offload to NICs</li> <li>eBPF: Use eBPF for packet filtering and routing</li> </ul>"},{"location":"roadmap/#implementation-priorities","title":"Implementation Priorities","text":""},{"location":"roadmap/#high-priority-next-3-months","title":"High Priority (Next 3 months)","text":"<ol> <li>Async data plane - unblock main thread</li> <li>Metrics export - essential for production</li> <li>Configuration hot reload - reduce operational friction</li> <li>Streaming bodies - reduce memory usage</li> <li>TLS peer verification - production security</li> </ol>"},{"location":"roadmap/#medium-priority-3-6-months","title":"Medium Priority (3-6 months)","text":"<ol> <li>Circuit breakers - improve reliability</li> <li>Distributed tracing - debugging complex issues</li> <li>Rate limiting - protect backends</li> <li>Health check improvements - reduce contention</li> <li>Admin API - operational visibility</li> </ol>"},{"location":"roadmap/#low-priority-6-months","title":"Low Priority (6+ months)","text":"<ol> <li>Dynamic backend discovery - integration complexity</li> <li>Advanced load balancing - diminishing returns</li> <li>WebAssembly plugins - adds complexity</li> <li>Protocol extensions - limited immediate value</li> <li>Multi-tenancy - niche use case</li> </ol>"},{"location":"roadmap/#technical-debt","title":"Technical Debt","text":""},{"location":"roadmap/#current-known-issues","title":"Current Known Issues","text":"<ol> <li>Blocking backend calls: Main thread blocks during HTTP/2 requests</li> <li>Full body buffering: High memory usage for large requests/responses</li> <li>Consistent hash rebuilds: Ring rebuilt on every request</li> <li>No metrics export: Metrics collected but not exposed</li> <li>Health check contention: Shares connection pool with production traffic</li> <li>Single-threaded: QUIC processing limited to one thread</li> <li>No TLS verification: Development-only security posture</li> </ol>"},{"location":"roadmap/#refactoring-needs","title":"Refactoring Needs","text":"<ol> <li>Error handling: Unify error types across crates</li> <li>Configuration: Type-safe config builders</li> <li>Testing: Expand integration test coverage</li> <li>Documentation: API documentation and examples</li> <li>Logging: Reduce debug log verbosity in hot path</li> </ol>"},{"location":"roadmap/#non-goals","title":"Non-Goals","text":"<p>Features explicitly not planned:</p> <ul> <li>Full service mesh: Focus remains on edge proxying</li> <li>Content caching: Use CDN or dedicated cache</li> <li>WAF capabilities: Use dedicated security tools</li> <li>Database proxying: Use specialized database proxies</li> <li>Custom protocols: Stick to HTTP family</li> </ul>"},{"location":"roadmap/#contributing","title":"Contributing","text":"<p>Contributions are welcome. See contributing guide for development setup and guidelines.</p> <p>Priority areas for contributions:</p> <ol> <li>Metrics export (Prometheus)</li> <li>Streaming request/response bodies</li> <li>Configuration hot reload</li> <li>Integration tests</li> <li>Documentation and examples</li> </ol>"},{"location":"api/overview/","title":"Overview","text":""},{"location":"api/overview/#api-reference","title":"API Reference","text":"<p>Spooky's programmatic interfaces and configuration APIs.</p>"},{"location":"api/overview/#command-line-interface","title":"Command Line Interface","text":""},{"location":"api/overview/#basic-usage","title":"Basic Usage","text":"<pre><code>spooky --config &lt;CONFIG&gt;\n</code></pre>"},{"location":"api/overview/#options","title":"Options","text":"Option Short Type Required Description <code>--config</code> <code>-c</code> string Yes Path to configuration file <code>--version</code> <code>-V</code> boolean No Show version information <code>--help</code> <code>-h</code> boolean No Show help information"},{"location":"api/overview/#examples","title":"Examples","text":"<pre><code># Start Spooky with configuration\nspooky --config /etc/spooky/config.yaml\n\n# Show version\nspooky --version\n</code></pre>"},{"location":"api/overview/#configuration-api","title":"Configuration API","text":""},{"location":"api/overview/#configuration-file-format","title":"Configuration File Format","text":"<p>Spooky uses YAML for configuration with the following structure:</p> <pre><code># Top-level configuration schema\nversion: 1                    # Configuration format version\nlisten:                       # Listener configuration (required)\nupstream:                     # Named upstream pools (required)\nload_balancing?:              # Global load balancing (optional)\nlog:                          # Logging configuration (optional, defaults applied)\n</code></pre>"},{"location":"api/overview/#type-definitions","title":"Type Definitions","text":""},{"location":"api/overview/#listenconfig","title":"ListenConfig","text":"<pre><code>interface ListenConfig {\n  protocol: \"http3\";     // Only HTTP/3 is supported\n  port: number;\n  address: string;\n  tls: TLSConfig;        // TLS is required for HTTP/3\n}\n</code></pre>"},{"location":"api/overview/#tlsconfig","title":"TLSConfig","text":"<pre><code>interface TLSConfig {\n  cert: string;        // Path to certificate file\n  key: string;         // Path to private key file\n  ca?: string;         // Path to CA certificate (client auth)\n}\n</code></pre>"},{"location":"api/overview/#upstreamconfig","title":"UpstreamConfig","text":"<pre><code>interface UpstreamConfig {\n  route: RouteConfig;             // Routing rules (required)\n  load_balancing?: LoadBalancingConfig;  // Per-upstream LB (planned, not implemented)\n  backends: BackendConfig[];      // Backend servers (required, at least 1)\n}\n</code></pre>"},{"location":"api/overview/#routeconfig","title":"RouteConfig","text":"<pre><code>interface RouteConfig {\n  host?: string;         // Host header to match (optional)\n  path_prefix?: string;  // Path prefix to match (optional, but at least one of host/path_prefix required)\n}\n</code></pre>"},{"location":"api/overview/#backendconfig","title":"BackendConfig","text":"<pre><code>interface BackendConfig {\n  id: string;          // Unique backend identifier\n  address: string;     // Backend address (host:port)\n  weight?: number;     // Load balancing weight (default: 100)\n  health_check?: HealthCheckConfig;\n}\n</code></pre>"},{"location":"api/overview/#healthcheckconfig","title":"HealthCheckConfig","text":"<pre><code>interface HealthCheckConfig {\n  path?: string;           // Health check endpoint (default: \"/health\")\n  interval?: number;       // Check interval in ms (default: 5000)\n  timeout_ms?: number;     // Request timeout in ms (default: 1000)\n  success_threshold?: number;   // Successes to mark healthy (default: 2)\n  failure_threshold?: number; // Failures to mark unhealthy (default: 3)\n  method?: string;         // HTTP method (default: \"GET\")\n}\n</code></pre>"},{"location":"api/overview/#loadbalancingconfig","title":"LoadBalancingConfig","text":"<pre><code>interface LoadBalancingConfig {\n  type: \"random\" | \"round-robin\" | \"consistent-hash\";\n  key?: string;  // Hash key source (planned: header:name, cookie:name, query:name, path)\n}\n</code></pre>"},{"location":"api/overview/#logconfig","title":"LogConfig","text":"<pre><code>interface LogConfig {\n  level?: string;  // Log level (default: \"info\")\n}\n</code></pre> <p>Supported log levels (in order of verbosity): - <code>whisper</code> - Trace-level logging (most verbose) - <code>haunt</code> - Debug-level logging - <code>spooky</code> - Info-level logging (default) - <code>scream</code> - Warning-level logging - <code>poltergeist</code> - Error-level logging - <code>silence</code> - Logging disabled</p> <p>Standard log levels are also supported: - <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>off</code></p>"},{"location":"api/overview/#metrics-system","title":"Metrics System","text":"<p>Spooky maintains internal performance and operational metrics tracked via atomic counters.</p>"},{"location":"api/overview/#current-available-metrics","title":"Current Available Metrics","text":"<p>The following metrics are currently tracked in-memory within the <code>Metrics</code> structure:</p>"},{"location":"api/overview/#request-metrics","title":"Request Metrics","text":"<ul> <li><code>requests_total</code> (AtomicU64) - Total number of requests received and processed</li> <li><code>requests_success</code> (AtomicU64) - Number of requests completed successfully with 2xx responses</li> <li><code>requests_failure</code> (AtomicU64) - Number of requests that failed or returned error responses</li> </ul>"},{"location":"api/overview/#backend-metrics","title":"Backend Metrics","text":"<ul> <li><code>backend_timeouts</code> (AtomicU64) - Number of requests that timed out waiting for backend response</li> <li><code>backend_errors</code> (AtomicU64) - Number of backend connection or communication errors</li> </ul>"},{"location":"api/overview/#metrics-implementation-details","title":"Metrics Implementation Details","text":"<p>All metrics use atomic operations with relaxed ordering for high-performance lock-free increment operations. Metrics are incremented through dedicated methods:</p> <ul> <li><code>inc_total()</code> - Increment total request counter</li> <li><code>inc_success()</code> - Increment successful request counter</li> <li><code>inc_failure()</code> - Increment failed request counter</li> <li><code>inc_timeout()</code> - Increment backend timeout counter</li> <li><code>inc_backend_error()</code> - Increment backend error counter</li> </ul>"},{"location":"api/overview/#future-metrics-api-endpoint","title":"Future: Metrics API Endpoint","text":"<p>Status: Planned feature</p> <p>A metrics exposition endpoint is planned for future implementation that will expose collected metrics for monitoring and observability systems.</p>"},{"location":"api/overview/#planned-endpoint","title":"Planned Endpoint","text":"<pre><code>GET /metrics\n</code></pre> <p>The endpoint will provide Prometheus-compatible metric exposition format, making Spooky metrics accessible to standard monitoring and alerting infrastructure.</p>"},{"location":"api/overview/#planned-metric-categories","title":"Planned Metric Categories","text":"<p>Future implementations may include:</p> <ul> <li>Request metrics: Total requests, success/failure rates, request duration histograms</li> <li>Connection metrics: Active QUIC connections, HTTP/2 connection pool statistics</li> <li>Backend health metrics: Backend availability, health check results, response times</li> <li>Load balancing metrics: Backend selection distribution, algorithm performance</li> <li>System metrics: Process resource usage, runtime statistics</li> </ul>"},{"location":"api/overview/#admin-api","title":"Admin API","text":"<p>Status: Future capability</p> <p>Administrative API endpoints are planned for runtime management and observability:</p>"},{"location":"api/overview/#planned-admin-capabilities","title":"Planned Admin Capabilities","text":"<ul> <li>Health endpoint: Spooky instance health status and backend health aggregation</li> <li>Metrics endpoint: Real-time operational metrics exposition</li> <li>Configuration reload: Dynamic configuration updates without restart</li> <li>Connection management: View active connections, drain connections gracefully</li> <li>Backend management: Enable/disable backends, adjust weights dynamically</li> </ul>"},{"location":"api/overview/#health-check-api","title":"Health Check API","text":""},{"location":"api/overview/#backend-health-checks","title":"Backend Health Checks","text":"<p>Spooky performs HTTP health checks against configured backends.</p>"},{"location":"api/overview/#request-format","title":"Request Format","text":"<pre><code>GET /health HTTP/1.1\nHost: backend.example.com:8080\nUser-Agent: spooky/0.1.0\n</code></pre>"},{"location":"api/overview/#expected-response","title":"Expected Response","text":"<p>Healthy Response (2xx status code): </p><pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"status\": \"healthy\", \"timestamp\": \"2024-01-01T12:00:00Z\"}\n</code></pre><p></p> <p>Unhealthy Response (non-2xx status code): </p><pre><code>HTTP/1.1 503 Service Unavailable\nContent-Type: application/json\n\n{\"status\": \"unhealthy\", \"reason\": \"database connection failed\"}\n</code></pre><p></p>"},{"location":"api/overview/#spooky-health-endpoint","title":"Spooky Health Endpoint","text":"<p>Status: Future feature</p> <p>A dedicated health endpoint for the Spooky instance is planned for future implementation:</p> <pre><code>GET /health HTTP/1.1\n</code></pre> <p>Planned response format: </p><pre><code>{\n  \"status\": \"healthy\",\n  \"version\": \"0.1.0\",\n  \"uptime\": 3600,\n  \"backends\": {\n    \"web-01\": \"healthy\",\n    \"web-02\": \"healthy\",\n    \"api-01\": \"unhealthy\"\n  }\n}\n</code></pre><p></p>"},{"location":"api/overview/#configuration-validation","title":"Configuration Validation","text":""},{"location":"api/overview/#startup-validation","title":"Startup Validation","text":"<p>Configuration validation is performed automatically at startup before the QUIC listener is initialized. The validation process verifies:</p> <ul> <li>Configuration file format and syntax</li> <li>Required field presence</li> <li>Value type correctness</li> <li>File path existence (certificates, keys)</li> <li>Network address format validity</li> </ul>"},{"location":"api/overview/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Configuration validated successfully, normal operation</li> <li><code>1</code>: Configuration validation failed or runtime error occurred</li> </ul>"},{"location":"api/overview/#validation-output","title":"Validation Output","text":"<p>Valid Configuration: </p><pre><code>Configuration validation successful\nSpooky is starting\nListening on 0.0.0.0:9889\n</code></pre><p></p> <p>Invalid Configuration: </p><pre><code>Error loading config: &lt;error details&gt;\n</code></pre><p></p> <p>or</p> <pre><code>Configuration validation failed. Exiting...\n</code></pre>"},{"location":"api/overview/#error-codes","title":"Error Codes","text":""},{"location":"api/overview/#http-status-codes","title":"HTTP Status Codes","text":"<p>Spooky may return the following HTTP status codes to clients:</p> <ul> <li><code>200 OK</code>: Request successful (forwarded from backend)</li> <li><code>400 Bad Request</code>: Malformed or invalid request</li> <li><code>500 Internal Server Error</code>: Internal proxy error (e.g., TLS configuration issues)</li> <li><code>502 Bad Gateway</code>: Backend server error</li> <li><code>503 Service Unavailable</code>: Backend timeout or no healthy backends available</li> </ul>"},{"location":"api/overview/#logging","title":"Logging","text":""},{"location":"api/overview/#log-format","title":"Log Format","text":"<p>Spooky uses the <code>env_logger</code> logging implementation with timestamped output. All log messages are written to standard output (stdout) with the following format:</p> <pre><code>[YYYY-MM-DD HH:MM:SS] [LEVEL] [module::path] message\n</code></pre>"},{"location":"api/overview/#log-output-examples","title":"Log Output Examples","text":"<pre><code>[2026-02-18 14:23:45] [INFO] [spooky] Spooky is starting\n[2026-02-18 14:23:45] [DEBUG] [spooky_edge::quic_listener] Listening on 0.0.0.0:9889\n[2026-02-18 14:23:45] [DEBUG] [spooky_edge::quic_listener] Certificate loaded successfully\n[2026-02-18 14:23:50] [INFO] [spooky_edge::quic_listener] Length of data received: 1200\n[2026-02-18 14:23:50] [DEBUG] [spooky_edge::quic_listener] Packet DCID (len=8): [00 01 02 03 04 05 06 07], type: Initial, active connections: 1\n[2026-02-18 14:25:30] [INFO] [spooky_edge::quic_listener] Draining connections\n[2026-02-18 14:25:35] [INFO] [spooky] Spooky shutdown complete\n</code></pre>"},{"location":"api/overview/#log-levels","title":"Log Levels","text":"<p>Log verbosity is configured via the <code>log.level</code> configuration parameter. The following levels are available (ordered from most to least verbose):</p> Level Standard Equivalent Use Case <code>whisper</code> trace Extremely detailed diagnostic information including packet hex dumps <code>haunt</code> debug Detailed diagnostic information for troubleshooting <code>spooky</code> info General informational messages about normal operation <code>scream</code> warn Warning messages for potentially problematic situations <code>poltergeist</code> error Error messages for failures and exceptions <code>silence</code> off Disable all logging output <p>Standard log level names (<code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>off</code>) are also supported for compatibility.</p>"},{"location":"api/overview/#log-configuration","title":"Log Configuration","text":"<p>Configure logging in the configuration file:</p> <pre><code>log:\n  level: \"spooky\"  # or \"haunt\", \"whisper\", etc.\n</code></pre>"},{"location":"api/overview/#environment-variable-control","title":"Environment Variable Control","text":"<p>The <code>env_logger</code> implementation respects the <code>RUST_LOG</code> environment variable, which can be used to override configuration file settings or enable module-specific logging:</p> <pre><code># Override global log level\nRUST_LOG=debug spooky --config config.yaml\n\n# Enable debug logging for specific modules\nRUST_LOG=spooky_edge=debug,spooky_transport=info spooky --config config.yaml\n\n# Trace all modules\nRUST_LOG=trace spooky --config config.yaml\n</code></pre>"},{"location":"api/overview/#environment-variables","title":"Environment Variables","text":"<p>Note: Environment variable interpolation in configuration files is not currently supported. Configuration values must be provided literally in the YAML file.</p> <p>For dynamic configuration, consider using external configuration management tools or templating the configuration file before loading.</p>"},{"location":"architecture/components/","title":"Components","text":""},{"location":"architecture/components/#component-architecture","title":"Component Architecture","text":"<p>This document provides a detailed breakdown of Spooky's modular component architecture, including responsibilities, APIs, and implementation details for each crate.</p>"},{"location":"architecture/components/#component-overview","title":"Component Overview","text":"<p>Spooky is organized as a Rust workspace with the following crates:</p> Crate Path Responsibility spooky <code>spooky/</code> Main binary and application lifecycle spooky-edge <code>crates/edge/</code> QUIC listener and HTTP/3 session management spooky-bridge <code>crates/bridge/</code> HTTP/3 to HTTP/2 protocol conversion spooky-transport <code>crates/transport/</code> HTTP/2 client and connection pooling spooky-lb <code>crates/lb/</code> Load balancing algorithms and health tracking spooky-config <code>crates/config/</code> Configuration parsing and validation spooky-utils <code>crates/utils/</code> TLS utilities and logging setup spooky-errors <code>crates/errors/</code> Shared error types (minimal)"},{"location":"architecture/components/#main-application-spooky","title":"Main Application (<code>spooky</code>)","text":""},{"location":"architecture/components/#responsibilities","title":"Responsibilities","text":"<ul> <li>Command-line argument parsing</li> <li>Configuration file loading</li> <li>Logger initialization</li> <li>QUIC listener creation</li> <li>Signal handling for graceful shutdown</li> <li>Event loop coordination</li> </ul>"},{"location":"architecture/components/#key-types","title":"Key Types","text":"<pre><code>struct Cli {\n    config: Option&lt;String&gt;,\n}\n</code></pre>"},{"location":"architecture/components/#main-flow","title":"Main Flow","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    // 1. Parse CLI arguments\n    let cli = Cli::parse();\n\n    // 2. Load configuration\n    let config = spooky_config::loader::read_config(&amp;config_path)?;\n\n    // 3. Initialize logger\n    spooky_utils::logger::init_logger(&amp;config.log.level);\n\n    // 4. Validate configuration\n    spooky_config::validator::validate(&amp;config);\n\n    // 5. Create QUIC listener\n    let mut listener = spooky_edge::QUICListener::new(config)?;\n\n    // 6. Setup shutdown handler\n    let shutdown = Arc::new(AtomicBool::new(false));\n    tokio::spawn(signal_handler(shutdown.clone()));\n\n    // 7. Main event loop\n    while !shutdown.load(Ordering::Relaxed) {\n        listener.poll();\n    }\n\n    // 8. Graceful shutdown\n    listener.start_draining();\n    while !listener.drain_complete() {\n        listener.poll();\n    }\n}\n</code></pre>"},{"location":"architecture/components/#dependencies","title":"Dependencies","text":"<ul> <li><code>clap</code>: CLI argument parsing</li> <li><code>tokio</code>: Async runtime</li> <li><code>log</code>: Logging facade</li> </ul>"},{"location":"architecture/components/#edge-listener-spooky-edge","title":"Edge Listener (<code>spooky-edge</code>)","text":""},{"location":"architecture/components/#responsibilities_1","title":"Responsibilities","text":"<ul> <li>UDP socket binding and management</li> <li>QUIC connection lifecycle (handshake, packet processing, closure)</li> <li>HTTP/3 session establishment via quiche</li> <li>Stream state management</li> <li>Request envelope construction</li> <li>Backend request forwarding</li> <li>Response streaming back to client</li> <li>Connection draining for graceful shutdown</li> <li>Metrics collection</li> </ul>"},{"location":"architecture/components/#key-types_1","title":"Key Types","text":"<pre><code>pub struct QUICListener {\n    pub socket: UdpSocket,\n    pub config: Config,\n    pub quic_config: quiche::Config,\n    pub h3_config: Arc&lt;quiche::h3::Config&gt;,\n    pub h2_pool: Arc&lt;H2Pool&gt;,\n    pub upstream_pools: HashMap&lt;String, Arc&lt;Mutex&lt;UpstreamPool&gt;&gt;&gt;,\n    pub load_balancer: LoadBalancing,\n    pub metrics: Metrics,\n    pub draining: bool,\n    pub drain_start: Option&lt;Instant&gt;,\n    pub recv_buf: [u8; 65535],\n    pub send_buf: [u8; 65535],\n    pub connections: HashMap&lt;Vec&lt;u8&gt;, QuicConnection&gt;,\n}\n\npub struct QuicConnection {\n    pub quic: quiche::Connection,\n    pub h3: Option&lt;quiche::h3::Connection&gt;,\n    pub h3_config: Arc&lt;quiche::h3::Config&gt;,\n    pub streams: HashMap&lt;u64, RequestEnvelope&gt;,\n    pub peer_address: SocketAddr,\n    pub last_activity: Instant,\n}\n\npub struct RequestEnvelope {\n    pub method: String,\n    pub path: String,\n    pub authority: Option&lt;String&gt;,\n    pub headers: Vec&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;,\n    pub body: Vec&lt;u8&gt;,\n    pub start: Instant,\n}\n\npub struct Metrics {\n    pub requests_total: AtomicU64,\n    pub requests_success: AtomicU64,\n    pub requests_failure: AtomicU64,\n    pub backend_timeouts: AtomicU64,\n    pub backend_errors: AtomicU64,\n}\n</code></pre>"},{"location":"architecture/components/#public-api","title":"Public API","text":"<pre><code>impl QUICListener {\n    /// Create new QUIC listener from configuration\n    pub fn new(config: Config) -&gt; Result&lt;Self, ProxyError&gt;;\n\n    /// Process pending packets and events (main event loop)\n    pub fn poll(&amp;mut self);\n\n    /// Begin graceful shutdown sequence\n    pub fn start_draining(&amp;mut self);\n\n    /// Check if drain is complete\n    pub fn drain_complete(&amp;self) -&gt; bool;\n}\n\nimpl Metrics {\n    pub fn inc_total(&amp;self);\n    pub fn inc_success(&amp;self);\n    pub fn inc_failure(&amp;self);\n    pub fn inc_timeout(&amp;self);\n    pub fn inc_backend_error(&amp;self);\n}\n</code></pre>"},{"location":"architecture/components/#implementation-details","title":"Implementation Details","text":"<p>Socket Management: - UDP socket bound to configured address:port - Non-blocking mode for poll-based processing - Fixed-size receive/send buffers (65535 bytes, max UDP payload)</p> <p>QUIC Configuration: - Built using quiche::Config - TLS credentials loaded from configured cert/key paths - HTTP/3 ALPN (\"h3\") configured - Connection ID generation using HMAC-SHA256 (stateless retry tokens)</p> <p>Connection Tracking: - Connections keyed by Server Connection ID (SCID) - Connection state includes QUIC and HTTP/3 layers - Last activity timestamp for idle timeout detection</p> <p>Request Processing: 1. Receive UDP datagram 2. Identify connection by DCID or create new connection 3. Feed packet to quiche 4. Poll HTTP/3 events 5. On headers: create RequestEnvelope 6. On body data: accumulate in envelope 7. On stream finished: process complete request 8. Route to upstream, select backend, forward request 9. Stream response back to client</p> <p>Upstream Routing: - Routes are matched by path prefix and optional host - Longest matching path wins for overlapping routes - No match returns error to client</p> <p>Health Integration: - Successful backend responses call <code>mark_success()</code> - Failed/timed out responses call <code>mark_failure()</code> - Health transitions are logged</p> <p>Graceful Shutdown: - <code>start_draining()</code> sets draining flag and records start time - No new requests accepted during drain - <code>drain_complete()</code> returns true when all connections closed or timeout reached - Drain timeout: 5 seconds</p>"},{"location":"architecture/components/#error-handling","title":"Error Handling","text":"<pre><code>pub enum ProxyError {\n    Bridge(BridgeError),\n    Transport(String),\n    Timeout,\n    Tls(String),\n}\n</code></pre> <p>Errors are logged and result in appropriate HTTP error responses to clients where possible.</p>"},{"location":"architecture/components/#dependencies_1","title":"Dependencies","text":"<ul> <li><code>quiche</code>: QUIC and HTTP/3 implementation</li> <li><code>tokio</code>: Async backend request execution</li> <li><code>bytes</code>: Efficient byte buffer handling</li> <li><code>http</code>: HTTP types for request construction</li> <li><code>spooky-config</code>: Configuration types</li> <li><code>spooky-lb</code>: Load balancing and health tracking</li> <li><code>spooky-bridge</code>: Protocol conversion</li> <li><code>spooky-transport</code>: HTTP/2 backend communication</li> </ul>"},{"location":"architecture/components/#protocol-bridge-spooky-bridge","title":"Protocol Bridge (<code>spooky-bridge</code>)","text":""},{"location":"architecture/components/#responsibilities_2","title":"Responsibilities","text":"<ul> <li>Convert HTTP/3 requests to HTTP/2 format</li> <li>Normalize headers between protocol versions</li> <li>Handle pseudo-headers (:method, :path, :authority, :scheme)</li> <li>Filter hop-by-hop headers</li> <li>Construct proper HTTP/2 request objects</li> </ul>"},{"location":"architecture/components/#key-types_2","title":"Key Types","text":"<pre><code>pub enum BridgeError {\n    InvalidMethod,\n    InvalidUri,\n    InvalidHeader,\n    Build(http::Error),\n}\n</code></pre>"},{"location":"architecture/components/#public-api_1","title":"Public API","text":"<pre><code>pub fn build_h2_request(\n    backend: &amp;str,\n    method: &amp;str,\n    path: &amp;str,\n    headers: &amp;[(Vec&lt;u8&gt;, Vec&lt;u8&gt;)],\n    body: &amp;[u8],\n) -&gt; Result&lt;Request&lt;Full&lt;Bytes&gt;&gt;, BridgeError&gt;;\n</code></pre>"},{"location":"architecture/components/#implementation-details_1","title":"Implementation Details","text":"<p>Method Conversion: - HTTP/3 method string parsed into <code>http::Method</code> - Validation ensures method is valid HTTP method</p> <p>URI Construction: - Backend address combined with request path - Format: <code>http://{backend}{path}</code> - Empty path defaults to \"/\" - Parsed into <code>http::Uri</code></p> <p>Header Processing: 1. Skip pseudo-headers (starting with ':') 2. Filter hop-by-hop headers (Connection, Keep-Alive, Transfer-Encoding, Upgrade) 3. Skip Content-Length (recalculated from body) 4. Ensure Host header present (from authority or backend address) 5. Set Content-Length if body is non-empty</p> <p>Body Handling: - Body copied into <code>Full&lt;Bytes&gt;</code> for hyper compatibility - Content-Length header set based on actual body size</p> <p>Edge Cases: - Missing Host: defaults to backend address - Empty path: defaults to \"/\" - Invalid headers: return BridgeError::InvalidHeader</p>"},{"location":"architecture/components/#error-handling_1","title":"Error Handling","text":"<p>All errors are propagated to caller with specific error types. Invalid requests are not sent to backends.</p>"},{"location":"architecture/components/#dependencies_2","title":"Dependencies","text":"<ul> <li><code>http</code>: HTTP types (Request, Method, Uri, HeaderName, HeaderValue)</li> <li><code>http-body-util</code>: Body utilities (Full)</li> <li><code>bytes</code>: Byte buffer types</li> <li><code>quiche</code>: HTTP/3 header types (NameValue)</li> </ul>"},{"location":"architecture/components/#transport-layer-spooky-transport","title":"Transport Layer (<code>spooky-transport</code>)","text":""},{"location":"architecture/components/#responsibilities_3","title":"Responsibilities","text":"<ul> <li>Maintain HTTP/2 connections to backend servers</li> <li>Connection pooling and reuse</li> <li>Request multiplexing over HTTP/2 connections</li> <li>Flow control via semaphore-based concurrency limiting</li> <li>Request forwarding with timeout handling</li> </ul>"},{"location":"architecture/components/#key-types_3","title":"Key Types","text":"<pre><code>pub struct H2Pool {\n    backends: HashMap&lt;String, BackendHandle&gt;,\n}\n\nstruct BackendHandle {\n    client: H2Client,\n    inflight: Arc&lt;Semaphore&gt;,\n}\n\npub struct H2Client {\n    client: Client&lt;HttpConnector, Full&lt;Bytes&gt;&gt;,\n}\n\npub enum PoolError {\n    UnknownBackend(String),\n    Send(hyper_util::client::legacy::Error),\n}\n</code></pre>"},{"location":"architecture/components/#public-api_2","title":"Public API","text":"<pre><code>impl H2Pool {\n    /// Create new pool with specified backends and concurrency limit\n    pub fn new&lt;I&gt;(backends: I, max_inflight: usize) -&gt; Self\n    where\n        I: IntoIterator&lt;Item = String&gt;;\n\n    /// Check if backend exists in pool\n    pub fn has_backend(&amp;self, backend: &amp;str) -&gt; bool;\n\n    /// Send request to specified backend\n    pub async fn send(\n        &amp;self,\n        backend: &amp;str,\n        req: Request&lt;Full&lt;Bytes&gt;&gt;,\n    ) -&gt; Result&lt;Response&lt;Incoming&gt;, PoolError&gt;;\n}\n\nimpl H2Client {\n    /// Create new HTTP/2-only client\n    pub fn new() -&gt; Self;\n\n    /// Send request over HTTP/2\n    pub async fn send(\n        &amp;self,\n        req: Request&lt;Full&lt;Bytes&gt;&gt;,\n    ) -&gt; Result&lt;Response&lt;Incoming&gt;, hyper_util::client::legacy::Error&gt;;\n}\n</code></pre>"},{"location":"architecture/components/#implementation-details_2","title":"Implementation Details","text":"<p>Connection Pooling: - One <code>BackendHandle</code> per backend address - Handle contains HTTP/2 client and concurrency limiter - Connections created lazily on first request - Connection reuse managed automatically by hyper</p> <p>Concurrency Control: - Semaphore limits concurrent requests per backend - Default: 64 concurrent requests per backend - Backpressure applied when limit reached (async wait) - Permit released when request completes</p> <p>HTTP/2 Client: - Built using hyper legacy client API - HTTP/2-only mode enforced - HttpConnector with HTTP enforcement disabled (allows non-HTTPS URIs) - TokioExecutor for spawning connection tasks</p> <p>Error Handling: - Unknown backend: <code>PoolError::UnknownBackend</code> - Connection errors: <code>PoolError::Send</code> wrapping hyper error - Timeout handled by caller (edge layer)</p>"},{"location":"architecture/components/#dependencies_3","title":"Dependencies","text":"<ul> <li><code>hyper</code>: HTTP client implementation</li> <li><code>hyper-util</code>: Connection pooling and legacy client</li> <li><code>http-body-util</code>: Body utilities</li> <li><code>tokio</code>: Async runtime</li> <li><code>bytes</code>: Byte buffers</li> </ul>"},{"location":"architecture/components/#load-balancer-spooky-lb","title":"Load Balancer (<code>spooky-lb</code>)","text":""},{"location":"architecture/components/#responsibilities_4","title":"Responsibilities","text":"<ul> <li>Backend selection algorithms (Random, Round Robin, Consistent Hash)</li> <li>Health state tracking per backend</li> <li>Failure threshold detection</li> <li>Recovery threshold tracking</li> <li>Cooldown period management</li> <li>Upstream pool management</li> </ul>"},{"location":"architecture/components/#key-types_4","title":"Key Types","text":"<pre><code>pub struct BackendState {\n    address: String,\n    weight: u32,\n    health_check: HealthCheck,\n    consecutive_failures: u32,\n    health_state: HealthState,\n}\n\nenum HealthState {\n    Healthy,\n    Unhealthy { until: Instant, successes: u32 },\n}\n\npub enum HealthTransition {\n    BecameHealthy,\n    BecameUnhealthy,\n}\n\npub struct BackendPool {\n    backends: Vec&lt;BackendState&gt;,\n}\n\npub struct UpstreamPool {\n    pub pool: BackendPool,\n    pub strategy: String,\n}\n\npub enum LoadBalancing {\n    RoundRobin(RoundRobin),\n    ConsistentHash(ConsistentHash),\n    Random(Random),\n}\n\npub struct RoundRobin {\n    next: usize,\n}\n\npub struct ConsistentHash {\n    replicas: u32,\n}\n\npub struct Random;\n</code></pre>"},{"location":"architecture/components/#public-api_3","title":"Public API","text":"<pre><code>impl BackendState {\n    pub fn new(backend: &amp;Backend) -&gt; Self;\n    pub fn is_healthy(&amp;self) -&gt; bool;\n    pub fn address(&amp;self) -&gt; &amp;str;\n    pub fn health_check(&amp;self) -&gt; &amp;HealthCheck;\n    pub fn weight(&amp;self) -&gt; u32;\n    pub fn record_success(&amp;mut self) -&gt; Option&lt;HealthTransition&gt;;\n    pub fn record_failure(&amp;mut self) -&gt; Option&lt;HealthTransition&gt;;\n}\n\nimpl BackendPool {\n    pub fn new_from_states(backends: Vec&lt;BackendState&gt;) -&gt; Self;\n    pub fn len(&amp;self) -&gt; usize;\n    pub fn is_empty(&amp;self) -&gt; bool;\n    pub fn address(&amp;self, index: usize) -&gt; Option&lt;&amp;str&gt;;\n    pub fn mark_success(&amp;mut self, index: usize) -&gt; Option&lt;HealthTransition&gt;;\n    pub fn mark_failure(&amp;mut self, index: usize) -&gt; Option&lt;HealthTransition&gt;;\n    pub fn health_check(&amp;self, index: usize) -&gt; Option&lt;HealthCheck&gt;;\n    pub fn healthy_indices(&amp;self) -&gt; Vec&lt;usize&gt;;\n    pub fn all_indices(&amp;self) -&gt; Vec&lt;usize&gt;;\n    pub fn backend(&amp;self, index: usize) -&gt; Option&lt;&amp;BackendState&gt;;\n}\n\nimpl UpstreamPool {\n    pub fn from_upstream(upstream: &amp;Upstream) -&gt; Result&lt;Self, String&gt;;\n}\n\nimpl LoadBalancing {\n    pub fn from_config(value: &amp;str) -&gt; Result&lt;Self, String&gt;;\n    pub fn pick(&amp;mut self, key: &amp;str, pool: &amp;UpstreamPool) -&gt; Option&lt;usize&gt;;\n}\n\nimpl RoundRobin {\n    pub fn new() -&gt; Self;\n    pub fn pick(&amp;mut self, pool: &amp;BackendPool) -&gt; Option&lt;usize&gt;;\n}\n\nimpl ConsistentHash {\n    pub fn new(replicas: u32) -&gt; Self;\n    pub fn pick(&amp;self, key: &amp;str, pool: &amp;BackendPool) -&gt; Option&lt;usize&gt;;\n}\n\nimpl Random {\n    pub fn new() -&gt; Self;\n    pub fn pick(&amp;mut self, pool: &amp;BackendPool) -&gt; Option&lt;usize&gt;;\n}\n</code></pre>"},{"location":"architecture/components/#implementation-details_3","title":"Implementation Details","text":"<p>Health State Machine:</p> <pre><code>Healthy\n  \u2502\n  \u2502 (failures &gt;= failure_threshold)\n  \u25bc\nUnhealthy { until: cooldown_end, successes: 0 }\n  \u2502\n  \u2502 (now &gt;= cooldown_end &amp;&amp; successes &gt;= success_threshold)\n  \u25bc\nHealthy\n</code></pre> <p>Health Tracking: - <code>record_success()</code>: Resets consecutive failures if healthy; increments success counter if unhealthy - <code>record_failure()</code>: Increments consecutive failures; transitions to unhealthy when threshold reached - Transitions return <code>Option&lt;HealthTransition&gt;</code> for logging</p> <p>Backend Selection: - Only healthy backends are candidates - If no healthy backends, returns None - Each algorithm filters to healthy backends before selection</p> <p>Round Robin: - Maintains next index counter - Wraps around when reaching end of healthy backends - Ensures even distribution across healthy backends</p> <p>Consistent Hash: - Builds hash ring with virtual nodes (replicas) - Replica count = base_replicas * backend_weight - Hash function: FNV-1a (fast, good distribution) - Key is hashed, closest node on ring is selected - Same key always routes to same backend (session affinity)</p> <p>Random: - Simple random selection from healthy backends - Uses thread-local RNG for performance - Uniform distribution</p> <p>Weight Support: - Weights affect consistent hash replica count - Higher weight = more virtual nodes = more traffic - Round robin and random ignore weights currently</p>"},{"location":"architecture/components/#algorithm-selection","title":"Algorithm Selection","text":"<p>Supported configuration strings: - \"round-robin\", \"round_robin\", \"rr\" \u2192 RoundRobin - \"consistent-hash\", \"consistent_hash\", \"ch\" \u2192 ConsistentHash - \"random\" \u2192 Random</p> <p>Default replicas for consistent hash: 64</p>"},{"location":"architecture/components/#dependencies_4","title":"Dependencies","text":"<ul> <li><code>rand</code>: Random number generation</li> <li><code>spooky-config</code>: Configuration types (Backend, HealthCheck, Upstream)</li> <li>Standard library: BTreeMap for hash ring, Duration/Instant for timing</li> </ul>"},{"location":"architecture/components/#configuration-system-spooky-config","title":"Configuration System (<code>spooky-config</code>)","text":""},{"location":"architecture/components/#responsibilities_5","title":"Responsibilities","text":"<ul> <li>YAML configuration parsing</li> <li>Configuration structure definitions</li> <li>Default value provision</li> <li>Configuration validation</li> <li>Error reporting for invalid configurations</li> </ul>"},{"location":"architecture/components/#key-types_5","title":"Key Types","text":"<pre><code>pub struct Config {\n    pub version: u32,\n    pub listen: Listen,\n    pub upstream: HashMap&lt;String, Upstream&gt;,\n    pub load_balancing: Option&lt;LoadBalancing&gt;,\n    pub log: Log,\n}\n\npub struct Listen {\n    pub protocol: String,\n    pub port: u32,\n    pub address: String,\n    pub tls: Tls,\n}\n\npub struct Tls {\n    pub cert: String,\n    pub key: String,\n}\n\npub struct Upstream {\n    pub load_balancing: LoadBalancing,\n    pub route: RouteMatch,\n    pub backends: Vec&lt;Backend&gt;,\n}\n\npub struct Backend {\n    pub id: String,\n    pub address: String,\n    pub weight: u32,\n    pub health_check: HealthCheck,\n}\n\npub struct RouteMatch {\n    pub host: Option&lt;String&gt;,\n    pub path_prefix: Option&lt;String&gt;,\n    pub method: Option&lt;String&gt;,\n}\n\npub struct HealthCheck {\n    pub path: String,\n    pub interval: u64,\n    pub timeout_ms: u64,\n    pub failure_threshold: u32,\n    pub success_threshold: u32,\n    pub cooldown_ms: u64,\n}\n\npub struct LoadBalancing {\n    pub lb_type: String,\n    pub key: Option&lt;String&gt;,\n}\n\npub struct Log {\n    pub level: String,\n}\n</code></pre>"},{"location":"architecture/components/#public-api_4","title":"Public API","text":"<pre><code>// loader.rs\npub fn read_config(path: &amp;str) -&gt; Result&lt;Config, String&gt;;\n\n// validator.rs\npub fn validate(config: &amp;Config) -&gt; bool;\n</code></pre>"},{"location":"architecture/components/#implementation-details_4","title":"Implementation Details","text":"<p>Configuration Loading: 1. Read file from path 2. Parse YAML via serde_yaml 3. Apply default values via serde defaults 4. Return Config or error message</p> <p>Default Values: - version: 1 - protocol: \"http3\" - port: 9889 - address: \"0.0.0.0\" - log level: \"info\" - backend weight: 100 - health check path: \"/health\" - health check interval: 5000ms - health timeout: 1000ms - failure threshold: 3 - success threshold: 2 - cooldown: 5000ms</p> <p>Validation Checks: 1. TLS certificate file exists and is readable 2. TLS key file exists and is readable 3. At least one upstream configured 4. Each upstream has at least one backend 5. Backend addresses are non-empty 6. Log level is valid</p> <p>Error Handling: - File not found: clear error message with path - Parse errors: YAML line/column information - Validation errors: specific validation failure message</p>"},{"location":"architecture/components/#dependencies_5","title":"Dependencies","text":"<ul> <li><code>serde</code>: Serialization framework</li> <li><code>serde_yaml</code>: YAML parsing</li> <li><code>log</code>: Logging</li> </ul>"},{"location":"architecture/components/#utilities-spooky-utils","title":"Utilities (<code>spooky-utils</code>)","text":""},{"location":"architecture/components/#responsibilities_6","title":"Responsibilities","text":"<ul> <li>TLS certificate and key loading</li> <li>Logging initialization</li> <li>Common helper functions</li> </ul>"},{"location":"architecture/components/#modules","title":"Modules","text":"<p>tls.rs: </p><pre><code>pub fn load_certs(path: &amp;str) -&gt; Result&lt;Vec&lt;Certificate&gt;, String&gt;;\npub fn load_private_key(path: &amp;str) -&gt; Result&lt;PrivateKey, String&gt;;\n</code></pre><p></p> <p>logger.rs: </p><pre><code>pub fn init_logger(level: &amp;str);\n</code></pre><p></p>"},{"location":"architecture/components/#implementation-details_5","title":"Implementation Details","text":"<p>TLS Loading: - Reads PEM files from filesystem - Parses DER-encoded certificates - Validates format - Returns rustls-compatible types</p> <p>Logger Initialization: - Configures env_logger with specified level - Maps custom log levels (if configured) - Enables timestamp and module path</p>"},{"location":"architecture/components/#dependencies_6","title":"Dependencies","text":"<ul> <li><code>rustls-pki-types</code>: TLS types</li> <li><code>env_logger</code>: Logging implementation</li> <li><code>log</code>: Logging facade</li> </ul>"},{"location":"architecture/components/#component-interaction-flow","title":"Component Interaction Flow","text":""},{"location":"architecture/components/#request-path","title":"Request Path","text":"<pre><code>Client HTTP/3 Request\n         \u25bc\n[spooky-edge::QUICListener]\n  \u251c\u2500 Receive QUIC packets\n  \u251c\u2500 Decode HTTP/3 headers\n  \u2514\u2500 Create RequestEnvelope\n         \u25bc\n[spooky-edge::quic_listener::find_upstream_for_request]\n  \u251c\u2500 Match path_prefix and host\n  \u2514\u2500 Select upstream pool\n         \u25bc\n[spooky-lb::LoadBalancing::pick]\n  \u251c\u2500 Filter to healthy backends\n  \u251c\u2500 Apply algorithm\n  \u2514\u2500 Return backend index\n         \u25bc\n[spooky-bridge::build_h2_request]\n  \u251c\u2500 Convert HTTP/3 \u2192 HTTP/2\n  \u251c\u2500 Normalize headers\n  \u2514\u2500 Construct Request&lt;Full&lt;Bytes&gt;&gt;\n         \u25bc\n[spooky-transport::H2Pool::send]\n  \u251c\u2500 Acquire semaphore permit\n  \u251c\u2500 Get backend client\n  \u2514\u2500 Forward request\n         \u25bc\nBackend HTTP/2 Server\n         \u25bc\n[spooky-edge::QUICListener]\n  \u251c\u2500 Receive response\n  \u251c\u2500 Update health state\n  \u251c\u2500 Update metrics\n  \u2514\u2500 Stream response to client\n</code></pre>"},{"location":"architecture/components/#configuration-path","title":"Configuration Path","text":"<pre><code>[spooky::main]\n  \u2514\u2500 Parse CLI args\n         \u25bc\n[spooky-config::loader::read_config]\n  \u251c\u2500 Read YAML file\n  \u2514\u2500 Parse with serde\n         \u25bc\n[spooky-config::validator::validate]\n  \u251c\u2500 Check TLS files\n  \u251c\u2500 Validate structure\n  \u2514\u2500 Return bool\n         \u25bc\n[spooky-edge::QUICListener::new]\n  \u251c\u2500 Load TLS via spooky-utils\n  \u251c\u2500 Create H2Pool with backends\n  \u251c\u2500 Create UpstreamPools\n  \u2514\u2500 Initialize load balancers\n         \u25bc\nRuntime\n</code></pre>"},{"location":"architecture/components/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/components/#unit-tests","title":"Unit Tests","text":"<p>Each crate includes unit tests for core functionality:</p> <p>spooky-lb: - Round robin cycling behavior - Consistent hash stability - Health state transitions - Backend recovery - Empty pool handling</p> <p>spooky-bridge: - Header conversion - Pseudo-header handling - URI construction - Error cases</p> <p>spooky-config: - YAML parsing - Default value application - Validation logic</p> <p>spooky-transport: - Pool initialization - Backend existence checks</p>"},{"location":"architecture/components/#integration-tests","title":"Integration Tests","text":"<p>spooky-edge: - Full request/response flow - Health check integration - Upstream routing - Multiple load balancing strategies</p>"},{"location":"architecture/components/#test-execution","title":"Test Execution","text":"<pre><code># All tests\ncargo test\n\n# Specific crate\ncargo test -p spooky-lb\n\n# Integration tests only\ncargo test -p spooky-edge --test lb_integration\n</code></pre>"},{"location":"architecture/components/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/components/#hot-path-optimizations","title":"Hot Path Optimizations","text":"<p>Zero-Copy Where Possible: - UDP receive buffer reused - QUIC packet processing avoids allocations - Header slices avoid string copies</p> <p>Lock-Free Metrics: - AtomicU64 for counters - No mutex on request path</p> <p>Connection Pooling: - HTTP/2 connection reuse - Amortize handshake cost</p> <p>Async I/O: - Backend requests with full body buffering (streaming planned) - Efficient task scheduling via Tokio</p>"},{"location":"architecture/components/#memory-management","title":"Memory Management","text":"<p>Fixed Buffers: - 64KB receive/send buffers per listener - No per-packet allocation</p> <p>Bounded Collections: - Connection map grows with active connections - Stream map per connection, cleared on completion</p> <p>Reference Counting: - Arc for shared config and pools - Amortize clone cost</p>"},{"location":"architecture/components/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"architecture/components/#binary-distribution","title":"Binary Distribution","text":"<p>Single statically-linked binary containing all components. No runtime dependencies except system TLS libraries.</p>"},{"location":"architecture/components/#resource-requirements","title":"Resource Requirements","text":"<ul> <li>File descriptors: 2 per backend + connection count</li> <li>Memory: ~1-2KB per QUIC connection + connection pools</li> <li>CPU: Scales with core count via Tokio runtime</li> <li>Network: UDP port for client traffic, TCP for backends</li> </ul>"},{"location":"architecture/components/#operational-checklist","title":"Operational Checklist","text":"<ol> <li>TLS certificates and keys readable by process user</li> <li>UDP port accessible for QUIC traffic</li> <li>Backend addresses reachable from proxy</li> <li>File descriptor limits sufficient (ulimit -n)</li> <li>Configuration validated before deployment</li> <li>Logging configured appropriately for environment</li> </ol>"},{"location":"architecture/components/#monitoring-recommendations","title":"Monitoring Recommendations","text":"<ul> <li>Track requests_total, requests_success, requests_failure</li> <li>Monitor backend_timeouts and backend_errors</li> <li>Alert on health state transitions</li> <li>Log slow requests (duration tracking)</li> <li>Monitor connection count</li> <li>Track memory usage growth</li> </ul>"},{"location":"architecture/overview/","title":"High-Level Design","text":""},{"location":"architecture/overview/#architecture-overview","title":"Architecture Overview","text":""},{"location":"architecture/overview/#introduction","title":"Introduction","text":"<p>Spooky is an HTTP/3 to HTTP/2 reverse proxy and load balancer implemented in Rust. It terminates QUIC connections at the edge and forwards HTTP requests to HTTP/2 backend servers, enabling modern HTTP/3 clients to communicate with existing HTTP/2 infrastructure without requiring backend modifications.</p>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":""},{"location":"architecture/overview/#performance","title":"Performance","text":"<p>Spooky is designed for high-performance operation with minimal overhead: - Zero-copy packet processing where possible - Lock-free data structures for hot paths - Asynchronous I/O throughout the stack - Connection pooling and multiplexing - Memory-efficient buffer management</p>"},{"location":"architecture/overview/#safety","title":"Safety","text":"<p>Built on Rust's memory safety guarantees: - No unsafe code in core proxy logic - Type-safe protocol conversions - Structured error handling with explicit failure modes - Resource lifetime tracking via ownership</p>"},{"location":"architecture/overview/#operational-simplicity","title":"Operational Simplicity","text":"<p>Simple to deploy and operate: - Single binary deployment - YAML-based configuration with validation - Graceful shutdown with connection draining - Hot configuration reload (planned) - Comprehensive metrics and logging</p>"},{"location":"architecture/overview/#modularity","title":"Modularity","text":"<p>Clear separation of concerns across crate boundaries: - Independent protocol layer implementations - Pluggable load balancing algorithms - Isolated configuration management - Reusable utility components</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":""},{"location":"architecture/overview/#high-level-view","title":"High-Level View","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 HTTP/3 Clients  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 QUIC/UDP\n         \u2502 TLS 1.3\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Spooky Edge                  \u2502\n\u2502                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  QUIC Listener (quiche)        \u2502     \u2502\n\u2502  \u2502  - Connection management       \u2502     \u2502\n\u2502  \u2502  - Stream multiplexing         \u2502     \u2502\n\u2502  \u2502  - TLS termination             \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502              \u2502                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Protocol Bridge               \u2502     \u2502\n\u2502  \u2502  - HTTP/3 \u2192 HTTP/2 conversion  \u2502     \u2502\n\u2502  \u2502  - Header normalization        \u2502     \u2502\n\u2502  \u2502  - Full body buffering (streaming planned)              \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502              \u2502                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Router &amp; Load Balancer        \u2502     \u2502\n\u2502  \u2502  - Path/host matching          \u2502     \u2502\n\u2502  \u2502  - Upstream selection          \u2502     \u2502\n\u2502  \u2502  - Health tracking             \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502              \u2502                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  HTTP/2 Connection Pool        \u2502     \u2502\n\u2502  \u2502  - Connection reuse            \u2502     \u2502\n\u2502  \u2502  - Request forwarding          \u2502     \u2502\n\u2502  \u2502  - Full response buffering (streaming planned)          \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 HTTP/2\n               \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502 Backend Pool  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/overview/#data-plane-and-control-plane","title":"Data Plane and Control Plane","text":"<p>The architecture separates data plane operations (request forwarding) from control plane operations (configuration, health checks, metrics):</p> <p>Data Plane: - QUIC packet processing - HTTP/3 stream handling - Protocol conversion - Backend request forwarding - Response streaming</p> <p>Control Plane: - Configuration loading and validation - Health check execution - Backend state management - Metrics collection - Connection lifecycle management</p> <p>This separation ensures that control plane operations do not block request processing on the hot path.</p>"},{"location":"architecture/overview/#request-processing-pipeline","title":"Request Processing Pipeline","text":""},{"location":"architecture/overview/#1-connection-establishment","title":"1. Connection Establishment","text":"<p>When a client initiates a connection: 1. UDP packets arrive at the bound socket 2. QUIC handshake is performed using quiche 3. TLS 1.3 credentials are validated 4. HTTP/3 session is established over QUIC 5. Connection state is tracked in the connections HashMap</p>"},{"location":"architecture/overview/#2-request-reception","title":"2. Request Reception","text":"<p>For each incoming HTTP/3 stream: 1. QUIC stream data is received 2. HTTP/3 headers are decoded via QPACK 3. Request envelope is created with method, path, authority, headers 4. Body data is accumulated as stream frames arrive 5. Stream state is maintained until request is complete</p>"},{"location":"architecture/overview/#3-routing-and-backend-selection","title":"3. Routing and Backend Selection","text":"<p>Once request headers are available: 1. Router matches request path and host against upstream pool routes 2. Longest matching path prefix wins for overlapping routes 3. Host-based routing is applied if configured 4. Selected upstream pool's load balancing strategy is invoked 5. Backend index is selected from healthy backends only 6. Backend address is retrieved from pool</p>"},{"location":"architecture/overview/#4-protocol-translation","title":"4. Protocol Translation","text":"<p>Before forwarding to backend: 1. HTTP/3 pseudo-headers (:method, :path, :authority) are extracted 2. HTTP/2 request is built with proper URI and method 3. Regular headers are copied, filtering hop-by-hop headers 4. Content-Length is set based on body size 5. Host header is ensured (using authority or backend address)</p>"},{"location":"architecture/overview/#5-backend-forwarding","title":"5. Backend Forwarding","text":"<p>Request is sent to selected backend: 1. HTTP/2 connection pool provides connection for backend address 2. Semaphore-based flow control limits concurrent requests per backend 3. Request is sent over HTTP/2 connection 4. Timeout is enforced at the transport layer 5. Backend response is awaited</p>"},{"location":"architecture/overview/#6-response-handling","title":"6. Response Handling","text":"<p>Backend response is processed: 1. HTTP/2 response is received from backend 2. Status code and headers are extracted 3. Response is written back to HTTP/3 stream 4. Body is buffered from backend and sent to client (streaming planned) 5. Stream is finalized when response is complete</p>"},{"location":"architecture/overview/#7-health-management","title":"7. Health Management","text":"<p>Backend health is tracked continuously: 1. Successful requests increment success counter 2. Failed requests increment failure counter 3. Consecutive failures beyond threshold mark backend unhealthy 4. Unhealthy backends enter cooldown period 5. Successful requests during recovery increment recovery counter 6. Backends return to healthy state after success threshold is met</p>"},{"location":"architecture/overview/#8-metrics-collection","title":"8. Metrics Collection","text":"<p>Throughout the pipeline, metrics are recorded: - Total requests received - Successful responses - Failed requests - Backend timeouts - Backend errors - Request latency (start to completion time)</p>"},{"location":"architecture/overview/#concurrency-model","title":"Concurrency Model","text":""},{"location":"architecture/overview/#async-runtime","title":"Async Runtime","text":"<p>Spooky uses Tokio as its asynchronous runtime: - Multi-threaded work-stealing scheduler - Event-driven I/O with epoll/kqueue - Timer wheel for timeout management - Cooperative task scheduling</p>"},{"location":"architecture/overview/#state-management","title":"State Management","text":"<p>Shared state is managed carefully: - <code>Arc&lt;T&gt;</code> for shared ownership - <code>Mutex&lt;T&gt;</code> for mutable shared state (upstream pools) - <code>AtomicU64</code> for lock-free counters (metrics) - Single-threaded UDP socket polling (no lock contention)</p>"},{"location":"architecture/overview/#task-structure","title":"Task Structure","text":"<p>The main event loop runs on the primary thread: - <code>poll()</code> processes UDP packets synchronously - QUIC connections are managed in-process - Backend requests spawn async tasks via Tokio - Graceful shutdown coordinated via AtomicBool</p> <p>This design avoids thread synchronization overhead on the packet processing path while leveraging Tokio's async capabilities for backend I/O.</p>"},{"location":"architecture/overview/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"architecture/overview/#error-categories","title":"Error Categories","text":"<p>Configuration Errors: - Detected at startup during validation - Cause process to exit before binding sockets - Examples: invalid TLS paths, malformed YAML, missing required fields</p> <p>Protocol Errors: - QUIC connection failures, stream errors, invalid HTTP/3 - Isolated to individual connections or streams - Do not affect other active connections - Logged for debugging</p> <p>Transport Errors: - Backend connection failures, timeouts, HTTP/2 errors - Trigger backend health state changes - May cause retry to different backend - Increment error metrics</p> <p>System Errors: - Socket errors, TLS failures, resource exhaustion - May require process restart depending on severity - Logged at error level with context</p>"},{"location":"architecture/overview/#recovery-mechanisms","title":"Recovery Mechanisms","text":"<p>Stream-Level Recovery: - Invalid stream fails with HTTP error to client - Connection remains active for other streams - Error logged with stream ID</p> <p>Backend-Level Recovery: - Failed backend marked unhealthy - Requests routed to healthy backends - Backend enters cooldown, recovers after success threshold - Health transitions logged</p> <p>Connection-Level Recovery: - Failed QUIC connection is closed - Other connections unaffected - Client may reconnect</p> <p>Process-Level Recovery: - Graceful shutdown on SIGTERM/SIGINT - Drain period allows in-flight requests to complete - Socket closure after drain timeout</p>"},{"location":"architecture/overview/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"architecture/overview/#structure","title":"Structure","text":"<p>Configuration is hierarchical: </p><pre><code>Config\n\u251c\u2500\u2500 version: u32\n\u251c\u2500\u2500 listen: Listen (protocol, port, address, TLS)\n\u251c\u2500\u2500 upstream: HashMap&lt;String, Upstream&gt;\n\u2502   \u2514\u2500\u2500 Upstream\n\u2502       \u251c\u2500\u2500 load_balancing: LoadBalancing\n\u2502       \u251c\u2500\u2500 route: RouteMatch (host, path_prefix)\n\u2502       \u2514\u2500\u2500 backends: Vec&lt;Backend&gt;\n\u2502           \u2514\u2500\u2500 Backend (id, address, weight, health_check)\n\u2514\u2500\u2500 log: Log (level)\n</code></pre><p></p>"},{"location":"architecture/overview/#validation","title":"Validation","text":"<p>Configuration validation occurs before runtime: 1. YAML parsing with serde 2. TLS certificate/key file existence checks 3. Backend address format validation 4. Load balancing mode validation 5. Route conflict detection (planned)</p>"},{"location":"architecture/overview/#runtime-behavior","title":"Runtime Behavior","text":"<p>Current configuration is immutable at runtime: - Loaded once at startup - Shared via Arc across components - Hot reload not yet implemented (requires atomic swap)</p>"},{"location":"architecture/overview/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/overview/#transport-security","title":"Transport Security","text":"<ul> <li>TLS 1.3 required for all client connections</li> <li>Certificate chain validation via rustls</li> <li>Private key protection (file permissions)</li> <li>ALPN negotiation ensures HTTP/3</li> </ul>"},{"location":"architecture/overview/#backend-communication","title":"Backend Communication","text":"<ul> <li>Currently plaintext HTTP/2</li> <li>Mutual TLS to backends (planned)</li> <li>Connection reuse reduces handshake overhead</li> </ul>"},{"location":"architecture/overview/#attack-surface","title":"Attack Surface","text":"<ul> <li>UDP amplification: QUIC includes mitigation (connection ID validation)</li> <li>Resource exhaustion: connection limits, per-backend semaphores</li> <li>Request smuggling: strict HTTP/3 to HTTP/2 conversion rules</li> <li>Header injection: header validation in bridge module</li> </ul>"},{"location":"architecture/overview/#observability","title":"Observability","text":""},{"location":"architecture/overview/#logging","title":"Logging","text":"<p>Structured logging via Rust's log crate: - Levels: trace, debug, info, warn, error - Context includes: connection ID, stream ID, backend, duration - Configurable log level at startup</p>"},{"location":"architecture/overview/#metrics","title":"Metrics","text":"<p>Atomic counters for key metrics: - <code>requests_total</code>: all requests received - <code>requests_success</code>: successful responses - <code>requests_failure</code>: failed requests - <code>backend_timeouts</code>: timed out backend requests - <code>backend_errors</code>: backend error responses</p> <p>Metrics export via Prometheus format (planned).</p>"},{"location":"architecture/overview/#tracing","title":"Tracing","text":"<p>Request-level tracing: - <code>RequestEnvelope</code> tracks start time - Duration calculated on completion - Logged with request details</p> <p>Distributed tracing via OpenTelemetry (planned).</p>"},{"location":"architecture/overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/overview/#latency","title":"Latency","text":"<ul> <li>QUIC handshake: 1-RTT with TLS 1.3</li> <li>Proxy overhead: sub-millisecond (header conversion, routing)</li> <li>Backend latency: dependent on backend response time</li> <li>End-to-end: dominated by backend latency</li> </ul>"},{"location":"architecture/overview/#throughput","title":"Throughput","text":"<ul> <li>Concurrent connections: 10,000+ QUIC connections</li> <li>Requests per second: 100,000+ on multi-core hardware</li> <li>Per-connection overhead: 1-2KB memory</li> <li>CPU: primarily driven by QUIC crypto and serialization</li> </ul>"},{"location":"architecture/overview/#scalability","title":"Scalability","text":"<ul> <li>Horizontal: stateless design allows multiple instances</li> <li>Vertical: work-stealing scheduler utilizes all cores</li> <li>Backend scaling: dynamic health-based routing</li> <li>Connection scaling: bounded by file descriptors and memory</li> </ul>"},{"location":"architecture/overview/#future-enhancements","title":"Future Enhancements","text":""},{"location":"architecture/overview/#planned-features","title":"Planned Features","text":"<ul> <li>Hot configuration reload without restart</li> <li>Prometheus metrics endpoint</li> <li>OpenTelemetry distributed tracing</li> <li>Mutual TLS to backends</li> <li>Active health check probes (TCP/HTTP)</li> <li>Rate limiting per client</li> <li>Circuit breaker pattern for failing backends</li> <li>Admin API for runtime inspection</li> </ul>"},{"location":"architecture/overview/#architectural-improvements","title":"Architectural Improvements","text":"<ul> <li>Lock-free routing table</li> <li>Connection state persistence for zero-downtime restart</li> <li>eBPF integration for packet-level optimizations</li> <li>QUIC 0-RTT support for returning clients</li> </ul>"},{"location":"configuration/reference/","title":"Reference","text":""},{"location":"configuration/reference/#configuration-reference","title":"Configuration Reference","text":"<p>Complete reference for all Spooky configuration options.</p>"},{"location":"configuration/reference/#configuration-file-format","title":"Configuration File Format","text":"<p>Spooky uses YAML for configuration. Specify the configuration file using the <code>--config</code> flag:</p> <pre><code>spooky --config /path/to/config.yaml\n</code></pre>"},{"location":"configuration/reference/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>version: 1\n\nlisten:\n  protocol: http3\n  address: \"0.0.0.0\"\n  port: 9889\n  tls:\n    cert: \"/etc/spooky/certs/fullchain.pem\"\n    key: \"/etc/spooky/certs/privkey.pem\"\n\nupstream:\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"\n      # key: \"header:x-user-id\"  # Planned feature, not currently supported\n\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/api\"\n\n    backends:\n      - id: \"api-01\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n          timeout_ms: 2000\n          failure_threshold: 3\n          success_threshold: 2\n          cooldown_ms: 5000\n\n      - id: \"api-02\"\n        address: \"10.0.1.11:8080\"\n        weight: 150\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  default_pool:\n    load_balancing:\n      type: \"round-robin\"\n\n    route:\n      path_prefix: \"/\"\n\n    backends:\n      - id: \"web-01\"\n        address: \"10.0.2.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/status\"\n          interval: 10000\n\nlog:\n  level: info\n</code></pre>"},{"location":"configuration/reference/#top-level-configuration","title":"Top-Level Configuration","text":""},{"location":"configuration/reference/#version","title":"version","text":"<p>Configuration schema version.</p> Property Type Required Default Description <code>version</code> integer No 1 Configuration schema version"},{"location":"configuration/reference/#listen","title":"listen","text":"<p>Server listening configuration. Defines the protocol, address, and port for incoming client connections.</p>"},{"location":"configuration/reference/#upstream","title":"upstream","text":"<p>Named upstream pool definitions. Each key represents a unique upstream pool with its own routing rules, load balancing strategy, and backend servers.</p>"},{"location":"configuration/reference/#load_balancing","title":"load_balancing","text":"<p>Deprecated. This top-level field is accepted by the parser for backward compatibility but has no effect at runtime. Configure load balancing strategy per upstream pool via <code>upstream.&lt;name&gt;.load_balancing</code> instead.</p>"},{"location":"configuration/reference/#log","title":"log","text":"<p>Logging configuration. Controls log level and output formatting.</p>"},{"location":"configuration/reference/#default-values","title":"Default Values","text":"<p>The following table lists all default configuration values used when properties are not explicitly specified:</p> Property Default Value Description <code>version</code> <code>1</code> Configuration format version <code>listen.protocol</code> <code>\"http3\"</code> Network protocol <code>listen.port</code> <code>9889</code> Listening port <code>listen.address</code> <code>\"0.0.0.0\"</code> Listening address <code>listen.tls.cert_file</code> Required TLS certificate file path <code>listen.tls.key_file</code> Required TLS private key file path <code>upstream[].route.path_prefix</code> <code>\"/\"</code> Path prefix for routing <code>upstream[].backends[].weight</code> <code>100</code> Backend weight for load balancing <code>upstream[].backends[].health_check.path</code> <code>\"/health\"</code> Health check endpoint <code>upstream[].backends[].health_check.interval</code> <code>5000</code> Health check interval (ms) <code>upstream[].backends[].health_check.timeout_ms</code> <code>1000</code> Health check timeout (ms) <code>upstream[].backends[].health_check.failure_threshold</code> <code>3</code> Failures to mark unhealthy <code>upstream[].backends[].health_check.success_threshold</code> <code>2</code> Successes to mark healthy <code>upstream[].backends[].health_check.cooldown_ms</code> <code>5000</code> Cooldown after failure (ms) <code>upstream[].load_balancing.type</code> <code>\"round-robin\"</code> Per-upstream load balancing algorithm <code>log.level</code> <code>\"info\"</code> Logging verbosity level <code>log.file.enabled</code> <code>false</code> Write logs to file instead of stderr <code>log.file.path</code> <code>\"/var/log/spooky/spooky.log\"</code> Log file path (used when <code>log.file.enabled</code> is true)"},{"location":"configuration/reference/#listen-configuration","title":"Listen Configuration","text":"<p>Configures the listening interface for incoming client connections. HTTP/3 requires TLS configuration.</p>"},{"location":"configuration/reference/#properties","title":"Properties","text":"Property Type Required Default Description <code>protocol</code> string No <code>http3</code> Protocol to listen on <code>address</code> string No <code>0.0.0.0</code> IP address to bind to <code>port</code> integer No <code>9889</code> Port to bind to <code>tls</code> object Yes - TLS configuration (required for HTTP/3)"},{"location":"configuration/reference/#protocol-values","title":"Protocol Values","text":"<ul> <li><code>http3</code>: HTTP/3 over QUIC (recommended)</li> </ul>"},{"location":"configuration/reference/#tls-configuration","title":"TLS Configuration","text":"Property Type Required Description <code>cert</code> string Yes Path to TLS certificate file (PEM format) <code>key</code> string Yes Path to TLS private key file (PEM format, PKCS#8 recommended)"},{"location":"configuration/reference/#examples","title":"Examples","text":"<pre><code># Standard HTTP/3 configuration\nlisten:\n  protocol: http3\n  address: \"0.0.0.0\"\n  port: 9889\n  tls:\n    cert: \"/etc/spooky/certs/server.crt\"\n    key: \"/etc/spooky/certs/server.key\"\n\n# Localhost-only development\nlisten:\n  protocol: http3\n  address: \"127.0.0.1\"\n  port: 9889\n  tls:\n    cert: \"certs/localhost.crt\"\n    key: \"certs/localhost.key\"\n</code></pre>"},{"location":"configuration/reference/#upstream-configuration","title":"Upstream Configuration","text":"<p>Upstream pools define groups of backend servers with routing rules and load balancing strategies. Each upstream pool is identified by a unique name and contains routing criteria, load balancing configuration, and backend definitions.</p>"},{"location":"configuration/reference/#structure","title":"Structure","text":"<pre><code>upstream:\n  pool_name:\n    load_balancing: &lt;LoadBalancing&gt;\n    route: &lt;RouteMatch&gt;\n    backends: [&lt;Backend&gt;]\n</code></pre>"},{"location":"configuration/reference/#properties_1","title":"Properties","text":"Property Type Required Default Description <code>load_balancing</code> object No round-robin Per-upstream load balancing algorithm configuration <code>route</code> object Yes - Route matching criteria <code>backends</code> array Yes - List of backend servers"},{"location":"configuration/reference/#route-matching","title":"Route Matching","text":"<p>Route matching determines which upstream pool handles a request. Routes are evaluated by longest-prefix matching across all configured upstreams, selecting the route with the most specific (longest) path prefix.</p>"},{"location":"configuration/reference/#routematch-properties","title":"RouteMatch Properties","text":"Property Type Required Default Description <code>host</code> string No - Host header to match (e.g., <code>api.example.com</code>) <code>path_prefix</code> string No - Path prefix to match (e.g., <code>/api</code>) <code>method</code> string No - HTTP method to match (reserved for future use) <p>Route matching rules:</p> <ol> <li>If <code>host</code> is specified, the request Host header must match exactly</li> <li>If <code>path_prefix</code> is specified, the request path must start with the prefix</li> <li>If both are specified, both conditions must match</li> <li>Routes are evaluated by longest-prefix matching - the route with the most specific (longest) path prefix is selected</li> <li>For routes with equal-length prefixes, selection depends on HashMap iteration order (not deterministic by configuration order)</li> </ol>"},{"location":"configuration/reference/#route-examples","title":"Route Examples","text":"<pre><code># Host-based routing\nupstream:\n  api_pool:\n    route:\n      host: \"api.example.com\"\n    backends: [...]\n\n  web_pool:\n    route:\n      host: \"www.example.com\"\n    backends: [...]\n\n# Path-based routing\nupstream:\n  api_pool:\n    route:\n      path_prefix: \"/api\"\n    backends: [...]\n\n  admin_pool:\n    route:\n      path_prefix: \"/admin\"\n    backends: [...]\n\n  default_pool:\n    route:\n      path_prefix: \"/\"\n    backends: [...]\n\n# Combined host and path routing\nupstream:\n  api_v2_pool:\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/v2\"\n    backends: [...]\n\n  api_v1_pool:\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/v1\"\n    backends: [...]\n</code></pre>"},{"location":"configuration/reference/#backend-configuration","title":"Backend Configuration","text":"<p>Each backend represents an upstream server that can handle requests.</p>"},{"location":"configuration/reference/#backend-properties","title":"Backend Properties","text":"Property Type Required Default Description <code>id</code> string Yes - Unique identifier for the backend <code>address</code> string Yes - Backend server address in <code>host:port</code> format <code>weight</code> integer No <code>100</code> Load balancing weight (higher values receive more traffic) <code>health_check</code> object Yes - Health check configuration"},{"location":"configuration/reference/#health-check-configuration","title":"Health Check Configuration","text":"<p>Health checks monitor backend availability and automatically remove unhealthy backends from the pool.</p> Property Type Required Default Description <code>path</code> string No <code>/health</code> HTTP path for health check requests <code>interval</code> integer No <code>5000</code> Health check interval in milliseconds <code>timeout_ms</code> integer No <code>1000</code> Health check timeout in milliseconds <code>failure_threshold</code> integer No <code>3</code> Consecutive failures before marking unhealthy <code>success_threshold</code> integer No <code>2</code> Consecutive successes before marking healthy <code>cooldown_ms</code> integer No <code>5000</code> Cooldown period after marking unhealthy (milliseconds) <p>Health check behavior:</p> <ol> <li>Health checks are performed at the specified <code>interval</code></li> <li>A backend is marked unhealthy after <code>failure_threshold</code> consecutive failures</li> <li>An unhealthy backend enters cooldown for <code>cooldown_ms</code> milliseconds</li> <li>After cooldown, health checks resume</li> <li>A backend is marked healthy after <code>success_threshold</code> consecutive successes</li> </ol>"},{"location":"configuration/reference/#backend-examples","title":"Backend Examples","text":"<pre><code># Minimal backend configuration\nbackends:\n  - id: \"backend1\"\n    address: \"10.0.1.10:8080\"\n    health_check:\n      path: \"/health\"\n\n# Weighted backend with custom health checks\nbackends:\n  - id: \"backend1\"\n    address: \"10.0.1.10:8080\"\n    weight: 100\n    health_check:\n      path: \"/api/health\"\n      interval: 10000\n      timeout_ms: 2000\n      failure_threshold: 5\n      success_threshold: 3\n      cooldown_ms: 10000\n\n  - id: \"backend2\"\n    address: \"10.0.1.11:8080\"\n    weight: 200\n    health_check:\n      path: \"/api/health\"\n      interval: 10000\n\n# Multiple backends with different health endpoints\nbackends:\n  - id: \"primary\"\n    address: \"10.0.1.10:8080\"\n    weight: 150\n    health_check:\n      path: \"/status\"\n      interval: 5000\n\n  - id: \"secondary\"\n    address: \"10.0.1.11:8080\"\n    weight: 100\n    health_check:\n      path: \"/healthz\"\n      interval: 5000\n</code></pre>"},{"location":"configuration/reference/#load-balancing-configuration","title":"Load Balancing Configuration","text":"<p>Load balancing determines how requests are distributed across healthy backends within an upstream pool. Each pool configures its own strategy independently.</p>"},{"location":"configuration/reference/#properties_2","title":"Properties","text":"Property Type Required Default Description <code>type</code> string Yes - Load balancing algorithm <code>key</code> string No - Hash key source for consistent hashing (planned feature)"},{"location":"configuration/reference/#supported-algorithms","title":"Supported Algorithms","text":""},{"location":"configuration/reference/#random","title":"random","text":"<p>Selects a backend randomly from all healthy backends. Weight values are currently ignored (weighted random is planned for future release).</p> <pre><code>upstream:\n  my_pool:\n    load_balancing:\n      type: \"random\"\n</code></pre>"},{"location":"configuration/reference/#round-robin","title":"round-robin","text":"<p>Distributes requests evenly across all healthy backends in sequential order. Weight values are currently ignored (weighted round-robin is planned for future release).</p> <pre><code>upstream:\n  my_pool:\n    load_balancing:\n      type: \"round-robin\"\n</code></pre>"},{"location":"configuration/reference/#consistent-hash","title":"consistent-hash","text":"<p>Routes requests using consistent hashing based on a fixed key derived from the request. Currently uses request authority (if present), otherwise request path, otherwise HTTP method.</p> <p>Note: Configurable key sources (headers, cookies, query parameters) are planned for future implementation.</p> <pre><code>upstream:\n  my_pool:\n    load_balancing:\n      type: \"consistent-hash\"\n      # key: \"header:x-user-id\"  # Planned feature, not currently supported\n</code></pre>"},{"location":"configuration/reference/#algorithm-selection","title":"Algorithm Selection","text":"<ul> <li>Use <code>random</code> for simple stateless load distribution</li> <li>Use <code>round-robin</code> for even distribution across backends</li> <li>Use <code>consistent-hash</code> when session affinity or request consistency is required</li> </ul>"},{"location":"configuration/reference/#examples_1","title":"Examples","text":"<pre><code>upstream:\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"\n    route:\n      path_prefix: \"/api\"\n    backends: [...]\n\n  default_pool:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/\"\n    backends: [...]\n</code></pre>"},{"location":"configuration/reference/#logging-configuration","title":"Logging Configuration","text":"<p>Controls logging output, verbosity, and destination.</p>"},{"location":"configuration/reference/#properties_3","title":"Properties","text":"Property Type Required Default Description <code>level</code> string No <code>info</code> Log level <code>file.enabled</code> bool No <code>false</code> Write logs to a file instead of stderr <code>file.path</code> string No <code>/var/log/spooky/spooky.log</code> Log file path (used when <code>file.enabled</code> is <code>true</code>)"},{"location":"configuration/reference/#log-levels","title":"Log Levels","text":"<p>Log levels in order of increasing verbosity:</p> <ul> <li><code>silence</code>: No logging output</li> <li><code>poltergeist</code>: Error messages only</li> <li><code>scream</code>: Warnings and errors</li> <li><code>spooky</code>: Informational messages, warnings, and errors</li> <li><code>haunt</code>: Debug information</li> <li><code>whisper</code>: Trace-level debugging</li> </ul> <p>Standard log level mapping:</p> <ul> <li><code>silence</code> = off</li> <li><code>poltergeist</code> = error</li> <li><code>scream</code> = warn</li> <li><code>spooky</code> = info</li> <li><code>haunt</code> = debug</li> <li><code>whisper</code> = trace</li> </ul>"},{"location":"configuration/reference/#examples_2","title":"Examples","text":"<pre><code># stderr only (default)\nlog:\n  level: info\n\n# Write to file\nlog:\n  level: info\n  file:\n    enabled: true\n    path: /var/log/spooky/spooky.log\n\n# Development \u2014 debug to stderr\nlog:\n  level: haunt  # debug level\n\n# Troubleshooting \u2014 trace to file\nlog:\n  level: whisper  # trace level\n  file:\n    enabled: true\n    path: /tmp/spooky-trace.log\n</code></pre>"},{"location":"configuration/reference/#configuration-validation","title":"Configuration Validation","text":"<p>Spooky validates configuration at startup and reports errors before attempting to start the server.</p>"},{"location":"configuration/reference/#common-validation-errors","title":"Common Validation Errors","text":"<ol> <li>Missing required fields</li> <li>TLS certificate or key paths not specified</li> <li>Backend address or ID missing</li> <li> <p>Route configuration empty</p> </li> <li> <p>Invalid file paths</p> </li> <li>TLS certificate file not found or not readable</li> <li>TLS key file not found or not readable</li> <li> <p>Incorrect file permissions</p> </li> <li> <p>Invalid values</p> </li> <li>Port number out of range (1-65535)</li> <li>Invalid IP address format</li> <li>Invalid backend address format (must be <code>host:port</code>)</li> <li> <p>Duplicate backend IDs within a pool</p> </li> <li> <p>Configuration conflicts</p> </li> <li>Port already in use</li> <li>Duplicate upstream pool names</li> <li>Overlapping or ambiguous route definitions</li> </ol>"},{"location":"configuration/reference/#testing-configuration","title":"Testing Configuration","text":"<p>Validate configuration without starting the server:</p> <pre><code>spooky --config &lt;path&gt;\n</code></pre> <p>The command exits with status 0 if configuration is valid, or prints detailed error messages and exits with non-zero status if invalid.</p>"},{"location":"configuration/reference/#complete-working-example","title":"Complete Working Example","text":"<pre><code>version: 1\n\nlisten:\n  protocol: http3\n  address: \"0.0.0.0\"\n  port: 9889\n  tls:\n    cert: \"certs/proxy-fullchain.pem\"\n    key: \"certs/proxy-key-pkcs8.pem\"\n\nupstream:\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"\n\n    route:\n      path_prefix: \"/api\"\n\n    backends:\n      - id: \"backend1\"\n        address: \"127.0.0.1:7001\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n      - id: \"backend2\"\n        address: \"127.0.0.1:7002\"\n        weight: 50\n        health_check:\n          path: \"/status\"\n          interval: 10000\n\n  default_pool:\n    load_balancing:\n      type: \"round-robin\"\n\n    route:\n      path_prefix: \"/\"\n\n    backends:\n      - id: \"auth1\"\n        address: \"127.0.0.1:8001\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\nlog:\n  level: debug\n</code></pre>"},{"location":"configuration/tls/","title":"TLS Setup","text":""},{"location":"configuration/tls/#tls-configuration","title":"TLS Configuration","text":"<p>Guide for configuring TLS certificates for HTTP/3 connections in Spooky.</p>"},{"location":"configuration/tls/#overview","title":"Overview","text":"<p>HTTP/3 uses QUIC as its transport protocol, which requires TLS 1.3 for encryption and authentication. Spooky requires valid TLS certificates to establish secure connections with clients.</p>"},{"location":"configuration/tls/#requirements","title":"Requirements","text":""},{"location":"configuration/tls/#protocol-requirements","title":"Protocol Requirements","text":"<ul> <li>TLS 1.3 (required for QUIC/HTTP3)</li> <li>ALPN (Application-Layer Protocol Negotiation) support</li> <li>SNI (Server Name Indication) support</li> </ul>"},{"location":"configuration/tls/#supported-formats","title":"Supported Formats","text":"<ul> <li>Certificates: PEM-encoded X.509 certificates</li> <li>Private Keys: PEM-encoded PKCS#8 format (recommended) or traditional RSA/ECDSA formats</li> <li>Key Types: RSA (2048-bit minimum) or ECDSA (P-256, P-384)</li> </ul>"},{"location":"configuration/tls/#certificate-generation","title":"Certificate Generation","text":""},{"location":"configuration/tls/#development-self-signed-certificates-with-mkcert","title":"Development: Self-Signed Certificates with mkcert","text":"<p>For local development, mkcert generates locally-trusted certificates:</p> <pre><code># Install mkcert\n# Ubuntu/Debian\nsudo apt install mkcert\n\n# macOS\nbrew install mkcert\n\n# Install local CA\nmkcert -install\n\n# Generate certificate for localhost\nmkdir -p certs\ncd certs\nmkcert -key-file server.key -cert-file server.crt localhost 127.0.0.1 ::1\n\n# Verify generation\nls -lh server.crt server.key\n</code></pre> <p>Configuration:</p> <pre><code>listen:\n  protocol: http3\n  port: 9889\n  address: \"127.0.0.1\"\n  tls:\n    cert: \"certs/server.crt\"\n    key: \"certs/server.key\"\n</code></pre>"},{"location":"configuration/tls/#development-self-signed-certificates-with-openssl","title":"Development: Self-Signed Certificates with OpenSSL","text":"<p>For environments where mkcert is not available:</p> <pre><code># Create certificate directory\nmkdir -p certs\ncd certs\n\n# Generate private key (RSA 2048-bit)\nopenssl genrsa -out server.key 2048\n\n# Generate certificate signing request\nopenssl req -new -key server.key -out server.csr \\\n  -subj \"/C=US/ST=State/L=City/O=Development/CN=localhost\"\n\n# Generate self-signed certificate (valid 365 days)\nopenssl x509 -req -in server.csr -signkey server.key \\\n  -out server.crt -days 365 -sha256\n\n# Convert key to PKCS#8 format (recommended)\nopenssl pkcs8 -topk8 -nocrypt -in server.key -out server-pkcs8.key\n\n# Verify certificate\nopenssl x509 -in server.crt -text -noout\n\n# Clean up CSR\nrm server.csr\n</code></pre> <p>Configuration:</p> <pre><code>listen:\n  protocol: http3\n  port: 9889\n  address: \"127.0.0.1\"\n  tls:\n    cert: \"certs/server.crt\"\n    key: \"certs/server-pkcs8.key\"\n</code></pre>"},{"location":"configuration/tls/#production-lets-encrypt","title":"Production: Let's Encrypt","text":"<p>For production deployments with public domains:</p> <pre><code># Install certbot\nsudo apt update\nsudo apt install certbot\n\n# Option 1: Standalone mode (requires port 80 available)\nsudo certbot certonly --standalone \\\n  -d example.com \\\n  -d www.example.com\n\n# Option 2: DNS challenge (no port requirements)\nsudo certbot certonly --manual \\\n  --preferred-challenges dns \\\n  -d example.com\n\n# Certificates are saved to:\n# Certificate: /etc/letsencrypt/live/example.com/fullchain.pem\n# Private Key: /etc/letsencrypt/live/example.com/privkey.pem\n</code></pre> <p>Configuration:</p> <pre><code>listen:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"/etc/letsencrypt/live/example.com/fullchain.pem\"\n    key: \"/etc/letsencrypt/live/example.com/privkey.pem\"\n</code></pre>"},{"location":"configuration/tls/#production-ecdsa-certificates","title":"Production: ECDSA Certificates","text":"<p>ECDSA certificates offer better performance than RSA:</p> <pre><code># Generate ECDSA private key (P-256)\nopenssl ecparam -genkey -name prime256v1 -out server-ec.key\n\n# Convert to PKCS#8 format\nopenssl pkcs8 -topk8 -nocrypt -in server-ec.key -out server-ec-pkcs8.key\n\n# Generate CSR\nopenssl req -new -key server-ec-pkcs8.key -out server-ec.csr \\\n  -subj \"/C=US/ST=State/L=City/O=Organization/CN=example.com\"\n\n# Generate self-signed certificate (or send CSR to CA)\nopenssl x509 -req -in server-ec.csr -signkey server-ec-pkcs8.key \\\n  -out server-ec.crt -days 365 -sha256\n</code></pre>"},{"location":"configuration/tls/#certificate-configuration","title":"Certificate Configuration","text":""},{"location":"configuration/tls/#basic-configuration","title":"Basic Configuration","text":"<p>Minimal TLS configuration for HTTP/3:</p> <pre><code>listen:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"/path/to/certificate.pem\"\n    key: \"/path/to/private-key.pem\"\n</code></pre>"},{"location":"configuration/tls/#path-specifications","title":"Path Specifications","text":"<p>Paths can be absolute or relative:</p> <pre><code># Absolute paths (recommended for production)\ntls:\n  cert: \"/etc/spooky/certs/fullchain.pem\"\n  key: \"/etc/spooky/certs/privkey.pem\"\n\n# Relative paths (relative to working directory)\ntls:\n  cert: \"certs/server.crt\"\n  key: \"certs/server.key\"\n</code></pre>"},{"location":"configuration/tls/#multi-domain-certificates","title":"Multi-Domain Certificates","text":"<p>For certificates covering multiple domains (SAN certificates):</p> <pre><code># Generate certificate with Subject Alternative Names\nopenssl req -new -x509 -key server.key -out server.crt -days 365 \\\n  -subj \"/CN=example.com\" \\\n  -addext \"subjectAltName=DNS:example.com,DNS:www.example.com,DNS:api.example.com\"\n</code></pre> <p>Configuration remains the same:</p> <pre><code>tls:\n  cert: \"/etc/spooky/certs/multi-domain.crt\"\n  key: \"/etc/spooky/certs/multi-domain.key\"\n</code></pre>"},{"location":"configuration/tls/#file-permissions-and-security","title":"File Permissions and Security","text":""},{"location":"configuration/tls/#recommended-permissions","title":"Recommended Permissions","text":"<p>Restrict access to certificate files:</p> <pre><code># Create dedicated certificate directory\nsudo mkdir -p /etc/spooky/certs\nsudo chown spooky:spooky /etc/spooky/certs\nsudo chmod 700 /etc/spooky/certs\n\n# Set certificate permissions\nsudo chmod 644 /etc/spooky/certs/server.crt\nsudo chmod 600 /etc/spooky/certs/server.key\n\n# Verify permissions\nls -l /etc/spooky/certs/\n</code></pre> <p>Expected output:</p> <pre><code>drwx------ 2 spooky spooky 4096 Dec 15 10:00 .\n-rw-r--r-- 1 spooky spooky 1234 Dec 15 10:00 server.crt\n-rw------- 1 spooky spooky 1704 Dec 15 10:00 server.key\n</code></pre>"},{"location":"configuration/tls/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Private Key Protection</li> <li>Never commit private keys to version control</li> <li>Use restrictive file permissions (600)</li> <li>Store keys on encrypted filesystems</li> <li> <p>Consider using hardware security modules (HSM) for production</p> </li> <li> <p>Certificate Chain Validation</p> </li> <li>Use complete certificate chains (fullchain.pem with Let's Encrypt)</li> <li>Include intermediate certificates</li> <li> <p>Verify chain with <code>openssl verify</code></p> </li> <li> <p>Certificate Monitoring</p> </li> <li>Monitor expiration dates</li> <li>Set up renewal automation for Let's Encrypt</li> <li>Implement alerting for certificates expiring within 30 days</li> </ol>"},{"location":"configuration/tls/#certificate-validation","title":"Certificate Validation","text":""},{"location":"configuration/tls/#verify-certificate-and-key-match","title":"Verify Certificate and Key Match","text":"<p>Ensure certificate and private key are paired correctly:</p> <pre><code># Extract modulus from certificate\ncert_modulus=$(openssl x509 -noout -modulus -in server.crt | md5sum)\n\n# Extract modulus from private key\nkey_modulus=$(openssl rsa -noout -modulus -in server.key | md5sum)\n\n# Compare (should be identical)\necho \"Certificate: $cert_modulus\"\necho \"Private Key: $key_modulus\"\n</code></pre> <p>For ECDSA keys:</p> <pre><code># Verify ECDSA private key\nopenssl ec -in server-ec.key -check\n\n# Verify certificate\nopenssl x509 -in server-ec.crt -text -noout\n</code></pre>"},{"location":"configuration/tls/#verify-certificate-properties","title":"Verify Certificate Properties","text":"<p>Check certificate details:</p> <pre><code># Display certificate information\nopenssl x509 -in server.crt -text -noout\n\n# Check expiration date\nopenssl x509 -in server.crt -noout -enddate\n\n# Check subject and issuer\nopenssl x509 -in server.crt -noout -subject -issuer\n\n# Verify certificate chain\nopenssl verify -CAfile ca.crt server.crt\n</code></pre>"},{"location":"configuration/tls/#test-configuration","title":"Test Configuration","text":"<p>Verify Spooky can load certificates:</p> <pre><code># Test configuration validity\nspooky --config config.yaml\n\n# Run in debug mode to see TLS initialization\n# Set log level in config.yaml (log.level) or via RUST_LOG=debug\nspooky --config config.yaml\n</code></pre>"},{"location":"configuration/tls/#certificate-rotation-and-renewal","title":"Certificate Rotation and Renewal","text":""},{"location":"configuration/tls/#lets-encrypt-automatic-renewal","title":"Let's Encrypt Automatic Renewal","text":"<p>Let's Encrypt certificates are valid for 90 days. Set up automatic renewal:</p> <pre><code># Test renewal process\nsudo certbot renew --dry-run\n\n# Enable automatic renewal (certbot installs systemd timer)\nsudo systemctl status certbot.timer\n\n# Manually renew certificates\nsudo certbot renew\n\n# Restart Spooky after renewal (hot reload planned)\nsudo systemctl restart spooky\n</code></pre>"},{"location":"configuration/tls/#manual-certificate-rotation","title":"Manual Certificate Rotation","text":"<p>For manually-managed certificates:</p> <pre><code># Backup current certificates\nsudo cp /etc/spooky/certs/server.crt /etc/spooky/certs/server.crt.backup\nsudo cp /etc/spooky/certs/server.key /etc/spooky/certs/server.key.backup\n\n# Install new certificates\nsudo cp new-server.crt /etc/spooky/certs/server.crt\nsudo cp new-server.key /etc/spooky/certs/server.key\n\n# Set permissions\nsudo chmod 644 /etc/spooky/certs/server.crt\nsudo chmod 600 /etc/spooky/certs/server.key\n\n# Restart Spooky (hot reload planned for future release)\nsudo systemctl restart spooky\n\n# Verify new certificates are loaded\nopenssl s_client -connect localhost:9889 -servername localhost &lt; /dev/null 2&gt;/dev/null | openssl x509 -noout -dates\n</code></pre>"},{"location":"configuration/tls/#monitoring-certificate-expiry","title":"Monitoring Certificate Expiry","text":"<p>Check certificate expiration:</p> <pre><code># Check days until expiry\nopenssl x509 -in /etc/spooky/certs/server.crt -noout -enddate\n\n# Calculate days remaining\ndays_left=$(( ($(date -d \"$(openssl x509 -in /etc/spooky/certs/server.crt -noout -enddate | cut -d= -f2)\" +%s) - $(date +%s)) / 86400 ))\necho \"Certificate expires in $days_left days\"\n\n# Alert if less than 30 days\nif [ $days_left -lt 30 ]; then\n  echo \"WARNING: Certificate expires soon!\"\nfi\n</code></pre>"},{"location":"configuration/tls/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/tls/#common-issues","title":"Common Issues","text":""},{"location":"configuration/tls/#certificate-file-not-found","title":"Certificate File Not Found","text":"<pre><code>Error: failed to read certificate file: No such file or directory\n</code></pre> <p>Solution:</p> <pre><code># Verify file exists\nls -l /etc/spooky/certs/server.crt\n\n# Check path in configuration\ncat config.yaml | grep -A2 tls\n\n# Use absolute paths\nrealpath certs/server.crt\n</code></pre>"},{"location":"configuration/tls/#permission-denied","title":"Permission Denied","text":"<pre><code>Error: failed to read certificate file: Permission denied\n</code></pre> <p>Solution:</p> <pre><code># Check file permissions\nls -l /etc/spooky/certs/\n\n# Fix permissions\nsudo chown spooky:spooky /etc/spooky/certs/server.{crt,key}\nsudo chmod 644 /etc/spooky/certs/server.crt\nsudo chmod 600 /etc/spooky/certs/server.key\n\n# Verify Spooky user can read files\nsudo -u spooky cat /etc/spooky/certs/server.crt &gt; /dev/null\n</code></pre>"},{"location":"configuration/tls/#invalid-certificate-format","title":"Invalid Certificate Format","text":"<pre><code>Error: failed to parse certificate: invalid PEM format\n</code></pre> <p>Solution:</p> <pre><code># Verify PEM format\nopenssl x509 -in server.crt -text -noout\n\n# Check file encoding\nfile server.crt\n\n# Convert DER to PEM if needed\nopenssl x509 -inform DER -in server.der -out server.pem\n</code></pre>"},{"location":"configuration/tls/#certificate-and-key-mismatch","title":"Certificate and Key Mismatch","text":"<pre><code>Error: certificate and private key do not match\n</code></pre> <p>Solution:</p> <pre><code># Verify certificate and key match (RSA)\nopenssl x509 -noout -modulus -in server.crt | md5sum\nopenssl rsa -noout -modulus -in server.key | md5sum\n\n# Verify ECDSA key\nopenssl ec -in server.key -pubout -out server-pub.pem\nopenssl x509 -in server.crt -pubkey -noout -out cert-pub.pem\ndiff server-pub.pem cert-pub.pem\n</code></pre>"},{"location":"configuration/tls/#pkcs8-format-required","title":"PKCS#8 Format Required","text":"<p>Some systems require PKCS#8 format:</p> <pre><code># Convert traditional RSA to PKCS#8\nopenssl pkcs8 -topk8 -nocrypt -in server.key -out server-pkcs8.key\n\n# Update configuration to use PKCS#8 key\n</code></pre>"},{"location":"configuration/tls/#testing-tls-connections","title":"Testing TLS Connections","text":""},{"location":"configuration/tls/#test-with-openssl","title":"Test with OpenSSL","text":"<pre><code># Test TLS 1.3 connection\necho -e \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | \\\n  openssl s_client -connect localhost:9889 -servername localhost -tls1_3\n\n# Display certificate chain\nopenssl s_client -connect localhost:9889 -servername localhost -showcerts &lt; /dev/null\n\n# Check ALPN negotiation\nopenssl s_client -connect localhost:9889 -servername localhost -alpn h3 &lt; /dev/null\n</code></pre>"},{"location":"configuration/tls/#test-with-curl-http3-support","title":"Test with cURL (HTTP/3 Support)","text":"<p>If curl is built with HTTP/3 support:</p> <pre><code># Test HTTP/3 connection\ncurl --http3 https://localhost:9889/\n\n# Verbose output for debugging\ncurl --http3 -v https://localhost:9889/\n\n# Test with self-signed certificate\ncurl --http3 -k https://localhost:9889/\n</code></pre>"},{"location":"configuration/tls/#debug-logging","title":"Debug Logging","text":"<p>Enable debug logging to troubleshoot TLS issues:</p> <pre><code>log:\n  level: debug\n</code></pre> <p>Look for log entries related to:</p> <ul> <li>Certificate loading</li> <li>TLS handshake</li> <li>QUIC connection establishment</li> <li>ALPN negotiation</li> </ul>"},{"location":"configuration/tls/#common-error-messages","title":"Common Error Messages","text":"Error Cause Solution <code>certificate has expired</code> Certificate validity period ended Renew certificate <code>certificate is not yet valid</code> System clock incorrect or certificate future-dated Check system time <code>unable to get local issuer certificate</code> Missing intermediate certificate Use fullchain.pem <code>self signed certificate</code> Client doesn't trust self-signed cert Use CA-signed cert or add to client trust store <code>wrong signature type</code> Key algorithm mismatch Ensure certificate and key use same algorithm"},{"location":"configuration/tls/#reference","title":"Reference","text":""},{"location":"configuration/tls/#configuration-schema","title":"Configuration Schema","text":"<pre><code>listen:\n  tls:\n    cert: string    # Path to PEM certificate file (required)\n    key: string     # Path to PEM private key file (required)\n</code></pre>"},{"location":"configuration/tls/#supported-key-algorithms","title":"Supported Key Algorithms","text":"<ul> <li>RSA 2048-bit (minimum)</li> <li>RSA 4096-bit (recommended for long-term use)</li> <li>ECDSA P-256 (secp256r1)</li> <li>ECDSA P-384 (secp384r1)</li> </ul>"},{"location":"configuration/tls/#certificate-requirements","title":"Certificate Requirements","text":"<ul> <li>PEM encoding</li> <li>X.509 format</li> <li>Valid date range (not expired, not future-dated)</li> <li>Subject Alternative Names (SAN) for multi-domain support</li> <li>Complete certificate chain (including intermediates)</li> </ul>"},{"location":"deployment/production/","title":"Production","text":""},{"location":"deployment/production/#production-deployment","title":"Production Deployment","text":"<p>Warning: Spooky is experimental software. It is not production-ready. This guide documents deployment procedures for evaluation and staging environments. Do not use Spooky in production without thoroughly understanding its current limitations (see Roadmap for known issues).</p> <p>This guide covers deployment procedures, system configuration, and operational considerations for Spooky HTTP/3 load balancer deployments.</p>"},{"location":"deployment/production/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":""},{"location":"deployment/production/#infrastructure-requirements","title":"Infrastructure Requirements","text":"<p>Compute Resources - CPU: 4 cores minimum (8+ for high-throughput deployments) - Memory: 4GB minimum (8GB+ recommended, ~1-2KB per concurrent connection) - Disk: 10GB minimum (configuration, logs, and binary storage) - OS: Linux kernel 5.0+ (Ubuntu 20.04 LTS, RHEL 8+, or equivalent)</p> <p>Network Requirements - UDP ingress on designated QUIC port (typically 443) - HTTP/2 egress to backend pool networks - Low-latency connectivity between proxy tier and backends (&lt;5ms RTT preferred) - MTU considerations: 1500 byte minimum, jumbo frames (9000 bytes) beneficial for high-throughput scenarios</p> <p>Certificate Infrastructure - Valid TLS certificates with full chain - Automated renewal mechanism (Let's Encrypt, internal PKI, or certificate management platform) - Certificate rotation procedures documented and tested</p>"},{"location":"deployment/production/#pre-deployment-validation","title":"Pre-Deployment Validation","text":"<p>Before deploying to production, verify the following:</p> <ol> <li>Configuration validated with <code>spooky --config &lt;path&gt;</code> (startup validation happens before serving)</li> <li>Backend health check endpoints operational and returning expected responses</li> <li>TLS certificates valid with appropriate SANs and expiration dates</li> <li>Firewall rules permit required traffic flows</li> <li>Service account and filesystem permissions configured</li> <li>Monitoring and alerting infrastructure ready to receive metrics</li> <li>Runbooks prepared for common failure scenarios</li> </ol>"},{"location":"deployment/production/#system-configuration","title":"System Configuration","text":""},{"location":"deployment/production/#binary-installation","title":"Binary Installation","text":"<p>Production deployments should use compiled release binaries:</p> <pre><code># Download release binary\nVERSION=\"0.1.0\"\nARCH=\"x86_64\"\nwget \"https://github.com/nishujangra/spooky/releases/download/v${VERSION}/spooky-linux-${ARCH}.tar.gz\"\ntar xzf \"spooky-linux-${ARCH}.tar.gz\"\n\n# Verify checksum\nsha256sum -c \"spooky-linux-${ARCH}.tar.gz.sha256\"\n\n# Install to system path\nsudo install -m 755 -o root -g root spooky /usr/local/bin/spooky\n\n# Create dedicated service account\nsudo useradd --system --shell /usr/sbin/nologin \\\n  --home-dir /var/lib/spooky --create-home spooky\n\n# Initialize directory structure\nsudo mkdir -p /etc/spooky/certs /var/log/spooky\nsudo chown -R root:spooky /etc/spooky\nsudo chmod 750 /etc/spooky\nsudo chown spooky:spooky /var/log/spooky\nsudo chmod 750 /var/log/spooky\n\n# Note: Spooky logs to stdout/stderr by default (collected by journald).\n# The /var/log/spooky directory is for optional file-based logging.\n</code></pre>"},{"location":"deployment/production/#kernel-parameter-tuning","title":"Kernel Parameter Tuning","text":"<p>UDP and QUIC workloads benefit from increased buffer sizes and connection tracking limits:</p> <pre><code># /etc/sysctl.d/99-spooky.conf\n# UDP receive/send buffer tuning\nnet.core.rmem_max = 67108864\nnet.core.wmem_max = 67108864\nnet.core.rmem_default = 16777216\nnet.core.wmem_default = 16777216\n\n# Network device backlog\nnet.core.netdev_max_backlog = 65536\nnet.core.netdev_budget = 50000\nnet.core.netdev_budget_usecs = 5000\n\n# Connection tracking (if using conntrack)\nnet.netfilter.nf_conntrack_max = 2097152\nnet.netfilter.nf_conntrack_tcp_timeout_established = 7200\nnet.netfilter.nf_conntrack_udp_timeout = 60\nnet.netfilter.nf_conntrack_udp_timeout_stream = 120\n\n# TCP tuning for HTTP/2 backend connections\nnet.ipv4.tcp_rmem = 8192 262144 33554432\nnet.ipv4.tcp_wmem = 8192 262144 33554432\nnet.ipv4.tcp_max_syn_backlog = 8192\nnet.ipv4.tcp_slow_start_after_idle = 0\nnet.ipv4.tcp_mtu_probing = 1\n\n# File descriptor limits\nfs.file-max = 2097152\n\n# Apply configuration\nsudo sysctl -p /etc/sysctl.d/99-spooky.conf\n</code></pre>"},{"location":"deployment/production/#resource-limits","title":"Resource Limits","text":"<p>Configure ulimits for the spooky service account:</p> <pre><code># /etc/security/limits.d/spooky.conf\nspooky soft nofile 1048576\nspooky hard nofile 1048576\nspooky soft nproc 16384\nspooky hard nproc 16384\nspooky soft memlock unlimited\nspooky hard memlock unlimited\n</code></pre>"},{"location":"deployment/production/#production-configuration","title":"Production Configuration","text":"<pre><code># /etc/spooky/config.yaml\nversion: 1\n\nlisten:\n  protocol: http3\n  address: \"0.0.0.0\"\n  port: 443\n  tls:\n    cert: \"/etc/spooky/certs/fullchain.pem\"\n    key: \"/etc/spooky/certs/privkey.pem\"\n\n# Define upstream pools with health checking\nupstream:\n  # API backend pool with consistent hashing for session affinity\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api-01\"\n        address: \"10.0.10.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n          timeout_ms: 2000\n          failure_threshold: 3\n          success_threshold: 2\n\n      - id: \"api-02\"\n        address: \"10.0.10.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n          timeout_ms: 2000\n          failure_threshold: 3\n          success_threshold: 2\n\n  # Static content pool with round-robin\n  static_pool:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/static\"\n    backends:\n      - id: \"static-01\"\n        address: \"10.0.20.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/\"\n          interval: 10000\n\n      - id: \"static-02\"\n        address: \"10.0.20.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/\"\n          interval: 10000\n\n  # Default backend pool\n  default_pool:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"web-01\"\n        address: \"10.0.30.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n# Logging configuration\nlog:\n  level: info  # Use 'warn' for production to reduce I/O\n\n# Connection tuning (if supported by configuration schema)\n# Adjust based on backend capacity and expected load\n# max_concurrent_connections: 10000\n# backend_connection_pool_size: 100\n</code></pre> <p>Configuration Notes: - Route matching uses longest-prefix: more specific paths take precedence - Health check intervals balance detection speed vs. backend load - Adjust <code>failure_threshold</code> and <code>success_threshold</code> based on backend stability - Weight distribution should reflect backend capacity - Consistent hashing is appropriate for stateful backends requiring session affinity</p>"},{"location":"deployment/production/#tls-certificate-management","title":"TLS Certificate Management","text":""},{"location":"deployment/production/#certificate-acquisition","title":"Certificate Acquisition","text":""},{"location":"deployment/production/#lets-encrypt-acme","title":"Let's Encrypt (ACME)","text":"<pre><code># Install certbot\nsudo apt-get install -y certbot\n\n# Obtain certificate (HTTP-01 challenge, requires port 80)\nsudo certbot certonly --standalone \\\n  --preferred-challenges http \\\n  --email ops@example.com \\\n  --agree-tos \\\n  --non-interactive \\\n  -d proxy.example.com\n\n# Copy to spooky directory\nsudo cp /etc/letsencrypt/live/proxy.example.com/fullchain.pem /etc/spooky/certs/\nsudo cp /etc/letsencrypt/live/proxy.example.com/privkey.pem /etc/spooky/certs/\nsudo chown root:spooky /etc/spooky/certs/*.pem\nsudo chmod 640 /etc/spooky/certs/privkey.pem\nsudo chmod 644 /etc/spooky/certs/fullchain.pem\n</code></pre>"},{"location":"deployment/production/#automated-renewal","title":"Automated Renewal","text":"<pre><code># Create renewal hook\nsudo tee /etc/letsencrypt/renewal-hooks/deploy/spooky-reload.sh &lt;&lt; 'EOF'\n#!/bin/bash\nset -e\n\nCERT_DOMAIN=\"proxy.example.com\"\nSPOOKY_CERT_DIR=\"/etc/spooky/certs\"\n\n# Copy renewed certificates\ncp \"/etc/letsencrypt/live/${CERT_DOMAIN}/fullchain.pem\" \"${SPOOKY_CERT_DIR}/\"\ncp \"/etc/letsencrypt/live/${CERT_DOMAIN}/privkey.pem\" \"${SPOOKY_CERT_DIR}/\"\n\n# Set permissions\nchown root:spooky \"${SPOOKY_CERT_DIR}\"/*.pem\nchmod 640 \"${SPOOKY_CERT_DIR}/privkey.pem\"\nchmod 644 \"${SPOOKY_CERT_DIR}/fullchain.pem\"\n\n# Reload spooky (graceful reload if supported, otherwise restart)\nsystemctl reload-or-restart spooky\n\nlogger -t spooky-cert-renewal \"TLS certificates renewed and spooky reloaded\"\nEOF\n\nsudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/spooky-reload.sh\n\n# Test renewal process\nsudo certbot renew --dry-run\n</code></pre>"},{"location":"deployment/production/#certificate-validation","title":"Certificate Validation","text":"<p>Before deploying new certificates:</p> <pre><code># Verify certificate and key match\nopenssl x509 -noout -modulus -in /etc/spooky/certs/fullchain.pem | openssl md5\nopenssl rsa -noout -modulus -in /etc/spooky/certs/privkey.pem | openssl md5\n\n# Verify certificate chain\nopenssl verify -CAfile /etc/spooky/certs/fullchain.pem /etc/spooky/certs/fullchain.pem\n\n# Check expiration\nopenssl x509 -noout -dates -in /etc/spooky/certs/fullchain.pem\n\n# Verify SAN entries\nopenssl x509 -noout -text -in /etc/spooky/certs/fullchain.pem | grep -A1 \"Subject Alternative Name\"\n</code></pre>"},{"location":"deployment/production/#systemd-service-configuration","title":"Systemd Service Configuration","text":""},{"location":"deployment/production/#service-unit","title":"Service Unit","text":"<pre><code># /etc/systemd/system/spooky.service\n[Unit]\nDescription=Spooky HTTP/3 to HTTP/2 Proxy\nDocumentation=https://github.com/nishujangra/spooky\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=simple\nUser=spooky\nGroup=spooky\n\n# Binary and configuration\nExecStart=/usr/local/bin/spooky --config /etc/spooky/config.yaml\n# Note: Hot reload not currently supported, use restart instead\n# ExecReload=/bin/kill -HUP $MAINPID\n\n# Restart policy\nRestart=always\nRestartSec=5s\nStartLimitBurst=3\nStartLimitIntervalSec=60s\n\n# Resource limits\nLimitNOFILE=1048576\nLimitNPROC=16384\nTasksMax=16384\n\n# Security hardening\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/var/log/spooky\nProtectKernelTunables=true\nProtectKernelModules=true\nProtectKernelLogs=true\nProtectControlGroups=true\nProtectProc=invisible\nProcSubset=pid\nRestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX\nRestrictNamespaces=true\nRestrictRealtime=true\nRestrictSUIDSGID=true\nLockPersonality=true\nSystemCallArchitectures=native\nSystemCallFilter=@system-service\nSystemCallFilter=~@privileged @resources\n\n# Logging\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=spooky\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"deployment/production/#service-management","title":"Service Management","text":"<pre><code># Install and enable service\nsudo systemctl daemon-reload\nsudo systemctl enable spooky.service\n\n# Start service\nsudo systemctl start spooky.service\n\n# Verify status\nsudo systemctl status spooky.service\n\n# View logs\nsudo journalctl -u spooky.service -f\n\n# Restart for configuration changes (hot reload planned)\nsudo systemctl restart spooky.service\n\n# Full restart\nsudo systemctl restart spooky.service\n</code></pre>"},{"location":"deployment/production/#security-hardening","title":"Security Hardening","text":""},{"location":"deployment/production/#network-security","title":"Network Security","text":"<p>Firewall Configuration (nftables)</p> <pre><code># /etc/nftables.conf (example rules)\ntable inet filter {\n    chain input {\n        type filter hook input priority filter; policy drop;\n\n        # Allow established/related connections\n        ct state established,related accept\n        ct state invalid drop\n\n        # Allow loopback\n        iif lo accept\n\n        # Allow SSH (restrict to management network)\n        ip saddr 10.0.0.0/24 tcp dport 22 ct state new accept\n\n        # Allow QUIC/HTTP3\n        udp dport 443 accept\n\n        # Allow health checks from monitoring (optional)\n        ip saddr 10.0.0.0/24 tcp dport 8080 ct state new accept\n\n        # Rate limiting for new connections\n        ct state new limit rate over 1000/second burst 2000 packets drop\n    }\n\n    chain forward {\n        type filter hook forward priority filter; policy drop;\n    }\n\n    chain output {\n        type filter hook output priority filter; policy accept;\n    }\n}\n</code></pre>"},{"location":"deployment/production/#application-security","title":"Application Security","text":"<p>Filesystem Permissions</p> <pre><code># Configuration immutable after validation\nsudo chown root:spooky /etc/spooky/config.yaml\nsudo chmod 640 /etc/spooky/config.yaml\nsudo chattr +i /etc/spooky/config.yaml  # Immutable (remove with -i for updates)\n\n# Certificate protection\nsudo chmod 640 /etc/spooky/certs/privkey.pem\nsudo chmod 644 /etc/spooky/certs/fullchain.pem\n</code></pre> <p>TLS Configuration</p> <p>Ensure TLS 1.3 is enforced with strong cipher suites. Note: cipher suite configuration may be limited by the underlying QUIC library (quiche). Verify supported options in the Spooky documentation.</p>"},{"location":"deployment/production/#selinux-apparmor","title":"SELinux / AppArmor","text":"<p>For environments requiring mandatory access control, create appropriate policies. Example AppArmor profile skeleton:</p> <pre><code># /etc/apparmor.d/usr.local.bin.spooky\n#include &lt;tunables/global&gt;\n\n/usr/local/bin/spooky {\n  #include &lt;abstractions/base&gt;\n  #include &lt;abstractions/nameservice&gt;\n\n  capability net_bind_service,\n  capability setuid,\n  capability setgid,\n\n  /usr/local/bin/spooky mr,\n  /etc/spooky/** r,\n  /var/log/spooky/** rw,\n\n  network inet dgram,\n  network inet6 dgram,\n  network inet stream,\n  network inet6 stream,\n}\n</code></pre>"},{"location":"deployment/production/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"deployment/production/#metrics-exposition","title":"Metrics Exposition","text":"<p>Note: Metrics exposition is planned for future releases but not currently implemented. Spooky currently maintains internal counters only.</p> <p>When metrics are implemented, they will follow Prometheus exposition format for easy integration with monitoring systems. Example configuration (for future reference):</p> <pre><code># prometheus.yml (planned)\nscrape_configs:\n  - job_name: 'spooky'\n    scrape_interval: 15s\n    scrape_timeout: 10s\n    metrics_path: '/metrics'  # To be implemented\n    static_configs:\n      - targets: ['spooky-01.internal:9090', 'spooky-02.internal:9090']\n        labels:\n          environment: 'production'\n          service: 'proxy'\n</code></pre>"},{"location":"deployment/production/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<p>Throughput Metrics - Requests per second (by route, backend, status code) - Bytes transferred (ingress/egress) - Active connections (QUIC, HTTP/2)</p> <p>Latency Metrics - Request duration percentiles (p50, p95, p99) - Backend response time - Connection establishment time - TLS handshake duration</p> <p>Error Metrics - HTTP 5xx error rate - Backend connection failures - Health check failure count - TLS handshake failures</p> <p>Resource Metrics - CPU utilization - Memory usage (RSS, heap) - File descriptor usage - Network buffer utilization</p>"},{"location":"deployment/production/#alerting-rules","title":"Alerting Rules","text":"<pre><code># prometheus-alerts.yml\ngroups:\n  - name: spooky-availability\n    rules:\n      - alert: SpookyInstanceDown\n        expr: up{job=\"spooky\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Spooky instance {{ $labels.instance }} is down\"\n          description: \"Instance has been unreachable for 1 minute\"\n\n      - alert: SpookyHighErrorRate\n        expr: |\n          (\n            sum(rate(http_requests_total{job=\"spooky\",status=~\"5..\"}[5m]))\n            /\n            sum(rate(http_requests_total{job=\"spooky\"}[5m]))\n          ) &gt; 0.05\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High 5xx error rate on Spooky\"\n          description: \"Error rate is {{ $value | humanizePercentage }}\"\n\n      - alert: SpookyBackendAllDown\n        expr: |\n          sum by (upstream_pool) (backend_healthy{job=\"spooky\"}) == 0\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"All backends down for pool {{ $labels.upstream_pool }}\"\n\n      - alert: SpookyLatencyHigh\n        expr: |\n          histogram_quantile(0.95,\n            sum(rate(http_request_duration_seconds_bucket{job=\"spooky\"}[5m])) by (le)\n          ) &gt; 1.0\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High request latency (p95 &gt; 1s)\"\n\n      - alert: SpookyFileDescriptorExhaustion\n        expr: process_open_fds{job=\"spooky\"} / process_max_fds{job=\"spooky\"} &gt; 0.8\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"File descriptor usage high on {{ $labels.instance }}\"\n\n  - name: spooky-capacity\n    rules:\n      - alert: SpookyCPUSaturation\n        expr: rate(process_cpu_seconds_total{job=\"spooky\"}[5m]) &gt; 0.8\n        for: 15m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"CPU saturation on {{ $labels.instance }}\"\n\n      - alert: SpookyMemoryPressure\n        expr: |\n          process_resident_memory_bytes{job=\"spooky\"} / node_memory_MemTotal_bytes &gt; 0.8\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Memory pressure on {{ $labels.instance }}\"\n</code></pre>"},{"location":"deployment/production/#log-management","title":"Log Management","text":"<p>Structured Logging</p> <p>Configure JSON output for log aggregation:</p> <pre><code>log:\n  level: info\n  format: json  # If supported\n</code></pre> <p>Log Aggregation</p> <p>Ship logs to centralized logging (ELK, Loki, Splunk):</p> <pre><code># Example: journald to Loki via Promtail\n# /etc/promtail/config.yml\nserver:\n  http_listen_port: 9080\n\npositions:\n  filename: /var/lib/promtail/positions.yaml\n\nclients:\n  - url: http://loki.internal:3100/loki/api/v1/push\n\nscrape_configs:\n  - job_name: systemd-journal\n    journal:\n      max_age: 12h\n      labels:\n        job: systemd-journal\n    relabel_configs:\n      - source_labels: ['__journal__systemd_unit']\n        target_label: 'unit'\n      - source_labels: ['__journal_syslog_identifier']\n        target_label: 'syslog_identifier'\n    pipeline_stages:\n      - match:\n          selector: '{syslog_identifier=\"spooky\"}'\n          stages:\n            - json:\n                expressions:\n                  level: level\n                  path: path\n                  backend: backend\n                  duration: duration\n            - labels:\n                level:\n                path:\n                backend:\n</code></pre> <p>Log Rotation</p> <p>Configure log rotation for file-based logging (when stdout/stderr is redirected to files):</p> <pre><code># /etc/logrotate.d/spooky\n/var/log/spooky/*.log {\n    daily\n    rotate 14\n    compress\n    delaycompress\n    missingok\n    notifempty\n    create 0640 spooky spooky\n    sharedscripts\n    postrotate\n        /bin/systemctl restart spooky.service &gt; /dev/null 2&gt;&amp;1 || true\n    endscript\n}\n</code></pre>"},{"location":"deployment/production/#high-availability-architecture","title":"High Availability Architecture","text":""},{"location":"deployment/production/#active-active-configuration","title":"Active-Active Configuration","text":"<p>Deploy multiple Spooky instances behind a UDP-capable load balancer:</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   DNS/GLB   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n         \u2502 L4 LB 1 \u2502              \u2502 L4 LB 2 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n              \u2502                         \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502             \u2502                          \u2502\n  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\n  \u2502Spooky 1\u2502   \u2502Spooky 2\u2502      ...       \u2502Spooky N\u2502\n  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n       \u2502             \u2502                          \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 Backend Pool   \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Layer 4 Load Balancer Options: - ECMP routing with consistent hashing - Anycast with BGP - Cloud provider UDP load balancers (AWS NLB, GCP Network Load Balancer)</p>"},{"location":"deployment/production/#configuration-synchronization","title":"Configuration Synchronization","text":"<p>Maintain consistent configuration across instances:</p> <pre><code># Use configuration management (Ansible example)\n# playbooks/deploy-spooky.yml\n- hosts: proxy_tier\n  become: yes\n  tasks:\n    - name: Deploy Spooky configuration\n      template:\n        src: templates/spooky-config.yaml.j2\n        dest: /etc/spooky/config.yaml\n        owner: root\n        group: spooky\n        mode: '0640'\n        # Note: Configuration validation happens during startup\n      notify: restart spooky\n\n    - name: Deploy TLS certificates\n      copy:\n        src: \"{{ item.src }}\"\n        dest: \"{{ item.dest }}\"\n        owner: root\n        group: spooky\n        mode: \"{{ item.mode }}\"\n      with_items:\n        - { src: 'certs/fullchain.pem', dest: '/etc/spooky/certs/fullchain.pem', mode: '0644' }\n        - { src: 'certs/privkey.pem', dest: '/etc/spooky/certs/privkey.pem', mode: '0640' }\n      notify: restart spooky\n\n  handlers:\n    - name: restart spooky\n      systemd:\n        name: spooky\n        state: restarted\n</code></pre>"},{"location":"deployment/production/#health-checking","title":"Health Checking","text":"<p>Implement external health checks for load balancer integration:</p> <pre><code># Health check script for L4 LB integration\n# /usr/local/bin/spooky-healthcheck.sh\n#!/bin/bash\nset -euo pipefail\n\n# Check if process is running\nif ! pgrep -x spooky &gt; /dev/null; then\n    exit 1\nfi\n\n# Check if listening on QUIC port (example: port 443)\nif ! ss -ulpn | grep -q \":443 \"; then\n    exit 1\nfi\n\n# Optional: Check internal health endpoint if available\n# curl -sf http://localhost:8080/health || exit 1\n\nexit 0\n</code></pre>"},{"location":"deployment/production/#performance-optimization","title":"Performance Optimization","text":""},{"location":"deployment/production/#connection-pooling","title":"Connection Pooling","text":"<p>Optimize HTTP/2 backend connection pool based on backend capacity:</p> <ul> <li>Typical ratio: 1 backend connection per 50-100 concurrent QUIC connections</li> <li>Monitor backend connection state and adjust pool size accordingly</li> <li>Consider backend connection limits and TCP socket exhaustion</li> </ul>"},{"location":"deployment/production/#quic-tuning","title":"QUIC Tuning","text":"<p>QUIC performance depends on UDP buffer sizes and packet processing:</p> <pre><code># Increase UDP receive buffer for high packet rates\n# Already covered in kernel tuning section, but worth emphasizing:\n# net.core.rmem_max = 67108864\n# net.core.rmem_default = 16777216\n\n# Verify current settings\nsysctl net.core.rmem_max\nsysctl net.core.rmem_default\n\n# Monitor UDP receive buffer overflows\nnetstat -su | grep \"receive errors\"\n</code></pre>"},{"location":"deployment/production/#cpu-affinity","title":"CPU Affinity","text":"<p>For multi-instance deployments on large systems, consider CPU pinning:</p> <pre><code># /etc/systemd/system/spooky@.service (template unit for multiple instances)\n[Service]\n# Pin instance 0 to CPUs 0-3, instance 1 to CPUs 4-7, etc.\nCPUAffinity=%i-$(((%i+1)*4-1))\n</code></pre>"},{"location":"deployment/production/#memory-management","title":"Memory Management","text":"<p>Monitor heap usage and consider tuning allocator behavior:</p> <pre><code># If using jemalloc (check with ldd /usr/local/bin/spooky)\n# Set environment variables for memory profiling\n# Environment=/usr/bin/env MALLOC_CONF=prof:true,prof_prefix:/var/log/spooky/jeprof\n</code></pre>"},{"location":"deployment/production/#operational-procedures","title":"Operational Procedures","text":""},{"location":"deployment/production/#deployment-process","title":"Deployment Process","text":"<ol> <li>Configuration Validation: Validate new configuration in staging environment</li> <li>Gradual Rollout: Deploy to canary instance first, monitor error rates and latency</li> <li>Progressive Deployment: Roll out to remaining instances with staggered timing</li> <li>Rollback Plan: Keep previous binary version and configuration for rapid rollback</li> </ol> <pre><code># Deployment script example\n#!/bin/bash\nset -euo pipefail\n\nNEW_VERSION=\"$1\"\nINSTANCES=(\"spooky-01\" \"spooky-02\" \"spooky-03\")\n\n# Deploy to canary\necho \"Deploying to canary: ${INSTANCES[0]}\"\nssh \"${INSTANCES[0]}\" \"sudo systemctl stop spooky &amp;&amp; \\\n  sudo cp /usr/local/bin/spooky /usr/local/bin/spooky.prev &amp;&amp; \\\n  sudo wget -O /usr/local/bin/spooky https://releases.example.com/spooky-${NEW_VERSION} &amp;&amp; \\\n  sudo systemctl start spooky\"\n\necho \"Canary deployed. Monitor metrics for 5 minutes...\"\nsleep 300\n\n# Check canary health\nif ! curl -sf \"http://${INSTANCES[0]}:8080/health\"; then\n    echo \"Canary health check failed. Rolling back.\"\n    ssh \"${INSTANCES[0]}\" \"sudo systemctl stop spooky &amp;&amp; \\\n      sudo mv /usr/local/bin/spooky.prev /usr/local/bin/spooky &amp;&amp; \\\n      sudo systemctl start spooky\"\n    exit 1\nfi\n\n# Deploy to remaining instances\nfor instance in \"${INSTANCES[@]:1}\"; do\n    echo \"Deploying to ${instance}\"\n    ssh \"${instance}\" \"sudo systemctl stop spooky &amp;&amp; \\\n      sudo cp /usr/local/bin/spooky /usr/local/bin/spooky.prev &amp;&amp; \\\n      sudo wget -O /usr/local/bin/spooky https://releases.example.com/spooky-${NEW_VERSION} &amp;&amp; \\\n      sudo systemctl start spooky\"\n    sleep 30\ndone\n\necho \"Deployment complete.\"\n</code></pre>"},{"location":"deployment/production/#configuration-changes","title":"Configuration Changes","text":"<pre><code># Test configuration before applying (startup validation will happen)\nsudo -u spooky spooky --config /etc/spooky/config.yaml.new\n\n# Atomic configuration update\nsudo mv /etc/spooky/config.yaml /etc/spooky/config.yaml.backup\nsudo mv /etc/spooky/config.yaml.new /etc/spooky/config.yaml\n\n# Restart service (hot reload planned for future release)\nsudo systemctl restart spooky.service\n\n# Verify reload success\nsudo systemctl status spooky.service\nsudo journalctl -u spooky.service -n 50 --no-pager\n</code></pre>"},{"location":"deployment/production/#incident-response","title":"Incident Response","text":"<p>High Error Rate</p> <ol> <li>Check backend health: <code>sudo journalctl -u spooky.service | grep \"health check\"</code></li> <li>Verify backend connectivity: <code>curl -v http://&lt;backend-ip&gt;:&lt;port&gt;/health</code></li> <li>Review recent configuration changes</li> <li>Check for backend capacity issues (CPU, memory, connection limits)</li> <li>If necessary, remove unhealthy backends from pool or rollback configuration</li> </ol> <p>Connection Exhaustion</p> <ol> <li>Check file descriptor usage: <code>ls /proc/$(pgrep spooky)/fd | wc -l</code></li> <li>Review ulimits: <code>cat /proc/$(pgrep spooky)/limits</code></li> <li>Identify connection leaks: <code>ss -anp | grep spooky | wc -l</code></li> <li>Restart service if connection leak suspected: <code>sudo systemctl restart spooky.service</code></li> </ol> <p>Memory Leak</p> <ol> <li>Monitor RSS over time: <code>ps aux | grep spooky</code></li> <li>Capture heap profile if using jemalloc</li> <li>Review recent traffic patterns for anomalies</li> <li>Restart service to recover capacity, engage upstream support</li> </ol>"},{"location":"deployment/production/#capacity-planning","title":"Capacity Planning","text":"<p>Monitor these indicators for scaling decisions:</p> <p>Scale Horizontally (Add Instances) When: - CPU utilization sustained &gt;70% across all instances - Network bandwidth saturation - Request queueing observed (increasing latency at constant RPS)</p> <p>Scale Vertically (Increase Resources) When: - Memory usage approaching limits - Context switching rate high with available CPU - Single-instance throughput below theoretical maximum</p> <p>Scaling Methodology: 1. Baseline current performance metrics 2. Load test with synthetic traffic at 2x current peak 3. Identify bottleneck (CPU, memory, network, backend capacity) 4. Size new deployment for 3x current peak with headroom 5. Implement autoscaling based on CPU/RPS metrics if using cloud infrastructure</p>"},{"location":"deployment/production/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/production/#diagnostic-commands","title":"Diagnostic Commands","text":"<pre><code># Process information\nps aux | grep spooky\npstree -p $(pgrep spooky)\n\n# Open file descriptors\nls -l /proc/$(pgrep spooky)/fd | wc -l\nlsof -p $(pgrep spooky) | head -20\n\n# Network connections\nss -anp | grep spooky | grep ESTABLISHED | wc -l\nss -anp | grep spooky | grep TIME-WAIT | wc -l\nss -su  # UDP socket statistics\n\n# System calls and performance\nstrace -c -p $(pgrep spooky) -e trace=network  # 10 second sample\nperf top -p $(pgrep spooky)\n\n# Memory analysis\ncat /proc/$(pgrep spooky)/status | grep -E \"Vm|Rss\"\npmap -x $(pgrep spooky)\n\n# Configuration verification\nsudo -u spooky spooky --config /etc/spooky/config.yaml\n</code></pre>"},{"location":"deployment/production/#common-issues","title":"Common Issues","text":"<p>Service Fails to Start</p> <p>Symptoms: systemd reports failure, process exits immediately</p> <p>Diagnosis: </p><pre><code># Check systemd logs\nsudo journalctl -u spooky.service -n 100 --no-pager\n\n# Test configuration manually\nsudo -u spooky /usr/local/bin/spooky --config /etc/spooky/config.yaml\n\n# Check certificate validity\nopenssl x509 -noout -dates -in /etc/spooky/certs/fullchain.pem\n\n# Verify file permissions\nls -la /etc/spooky/certs/\n</code></pre><p></p> <p>Resolution: Address configuration errors, certificate issues, or permission problems identified above.</p> <p>High Latency</p> <p>Symptoms: Increased p95/p99 request duration</p> <p>Diagnosis: </p><pre><code># Check backend latency\ncurl -w \"@curl-format.txt\" -o /dev/null -s http://&lt;backend&gt;/&lt;path&gt;\n\n# Network path latency\nmtr &lt;backend-ip&gt;\n\n# System resource contention\ntop -p $(pgrep spooky)\niostat -x 1 10\n\n# Connection state distribution\nss -anp | grep spooky | awk '{print $2}' | sort | uniq -c\n</code></pre><p></p> <p>Resolution: Investigate backend performance, network conditions, or system resource exhaustion.</p> <p>Backend Connection Failures</p> <p>Symptoms: 502/503 errors, \"connection refused\" in logs</p> <p>Diagnosis: </p><pre><code># Verify backend reachability\nnc -zv &lt;backend-ip&gt; &lt;backend-port&gt;\n\n# Check backend process state\nssh &lt;backend&gt; \"systemctl status &lt;backend-service&gt;\"\n\n# Firewall/security group verification\nsudo iptables -L -n -v | grep &lt;backend-ip&gt;\n\n# Review health check logs\nsudo journalctl -u spooky.service | grep \"health check\"\n</code></pre><p></p> <p>Resolution: Restore backend service, fix network connectivity, or adjust health check parameters.</p>"},{"location":"deployment/production/#backup-and-disaster-recovery","title":"Backup and Disaster Recovery","text":""},{"location":"deployment/production/#configuration-backup","title":"Configuration Backup","text":"<pre><code># /usr/local/bin/backup-spooky-config.sh\n#!/bin/bash\nset -euo pipefail\n\nBACKUP_ROOT=\"/var/backups/spooky\"\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\nBACKUP_DIR=\"${BACKUP_ROOT}/${TIMESTAMP}\"\n\nmkdir -p \"${BACKUP_DIR}\"\n\n# Backup configuration\ncp -a /etc/spooky/config.yaml \"${BACKUP_DIR}/\"\n\n# Backup certificates (excluding private keys for security)\ncp /etc/spooky/certs/fullchain.pem \"${BACKUP_DIR}/\"\n\n# Store metadata\ncat &gt; \"${BACKUP_DIR}/metadata.txt\" &lt;&lt; EOF\nBackup Date: $(date -Is)\nHostname: $(hostname -f)\nSpooky Version: $(spooky --version 2&gt;&amp;1 || echo \"unknown\")\nEOF\n\n# Compress backup\ntar czf \"${BACKUP_ROOT}/spooky-config-${TIMESTAMP}.tar.gz\" -C \"${BACKUP_ROOT}\" \"${TIMESTAMP}\"\nrm -rf \"${BACKUP_DIR}\"\n\n# Rotate old backups (keep 30 days)\nfind \"${BACKUP_ROOT}\" -name \"spooky-config-*.tar.gz\" -mtime +30 -delete\n\necho \"Backup completed: ${BACKUP_ROOT}/spooky-config-${TIMESTAMP}.tar.gz\"\n</code></pre> <p>Schedule via cron: </p><pre><code># Run daily at 2 AM\n0 2 * * * /usr/local/bin/backup-spooky-config.sh &gt;&gt; /var/log/spooky/backup.log 2&gt;&amp;1\n</code></pre><p></p>"},{"location":"deployment/production/#recovery-procedures","title":"Recovery Procedures","text":"<p>Configuration Restoration </p><pre><code># Extract backup\ntar xzf /var/backups/spooky/spooky-config-YYYYMMDD-HHMMSS.tar.gz -C /tmp\n\n# Restore configuration\nsudo cp /tmp/YYYYMMDD-HHMMSS/config.yaml /etc/spooky/config.yaml\nsudo chown root:spooky /etc/spooky/config.yaml\nsudo chmod 640 /etc/spooky/config.yaml\n\n# Restart service (hot reload not currently supported)\nsudo systemctl restart spooky.service\n</code></pre><p></p> <p>Complete System Rebuild 1. Provision new host with OS installation 2. Apply system configuration (kernel tuning, resource limits) 3. Install Spooky binary 4. Restore configuration from backup 5. Install TLS certificates 6. Start service and verify health 7. Update load balancer to include new instance</p> <p>Recovery Time Objective (RTO): Target &lt;15 minutes with automation Recovery Point Objective (RPO): Configuration changes backed up daily</p>"},{"location":"deployment/production/#maintenance-windows","title":"Maintenance Windows","text":""},{"location":"deployment/production/#planned-maintenance-checklist","title":"Planned Maintenance Checklist","text":"<p>Pre-Maintenance - [ ] Notify stakeholders of maintenance window - [ ] Verify backup procedures completed successfully - [ ] Review rollback procedures - [ ] Prepare configuration changes or binary updates - [ ] Verify staging environment changes successful</p> <p>During Maintenance - [ ] Remove instance from load balancer (if applicable) - [ ] Drain existing connections (if graceful shutdown supported) - [ ] Apply updates (configuration, binary, certificates) - [ ] Restart service - [ ] Verify service health and connectivity - [ ] Monitor error rates and latency for 5 minutes - [ ] Return instance to load balancer</p> <p>Post-Maintenance - [ ] Confirm all instances operational - [ ] Review metrics for anomalies - [ ] Update change log - [ ] Close maintenance notification</p>"},{"location":"deployment/production/#additional-resources","title":"Additional Resources","text":"<ul> <li>Spooky Configuration Reference: <code>/docs/configuration/reference.md</code></li> <li>Load Balancing Strategies: <code>/docs/user-guide/load-balancing.md</code></li> <li>Troubleshooting Guide: <code>/docs/troubleshooting/common-issues.md</code></li> <li>Architecture Overview: <code>/docs/architecture/overview.md</code></li> </ul> <p>For issues not covered in this guide, consult the project repository issue tracker or engage with the development team.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#installation","title":"Installation","text":""},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>Hardware: - CPU: 1 core minimum (2+ cores recommended for production) - Memory: 256MB RAM minimum (1GB+ recommended) - Disk: 100MB for binary and configuration files - Network: UDP port access for QUIC traffic</p> <p>Software: - Rust 1.85 or later (2024 edition) - Operating System: Linux, macOS, or Windows - Build tools: CMake, pkg-config, C compiler toolchain</p> <p>Permissions: - Spooky must run as root (required for QUIC/UDP socket binding)</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release from GitHub Releases.</p> <p>Linux (x86_64): </p><pre><code>wget https://github.com/nishujangra/spooky/releases/download/v0.1.0/spooky-linux-x86_64.tar.gz\ntar -xzf spooky-linux-x86_64.tar.gz\nsudo install -m 755 spooky /usr/local/bin/spooky\n</code></pre><p></p> <p>macOS (x86_64/ARM64): </p><pre><code>wget https://github.com/nishujangra/spooky/releases/download/v0.1.0/spooky-macos-universal.tar.gz\ntar -xzf spooky-macos-universal.tar.gz\nsudo install -m 755 spooky /usr/local/bin/spooky\n</code></pre><p></p>"},{"location":"getting-started/installation/#cargo-install","title":"Cargo Install","text":"<p>Install directly from crates.io:</p> <pre><code>cargo install spooky\n</code></pre> <p>This compiles from source and installs to <code>~/.cargo/bin/</code>. Ensure this directory is in your PATH.</p>"},{"location":"getting-started/installation/#build-from-source","title":"Build from Source","text":"<p>Clone and build: </p><pre><code>git clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\n</code></pre><p></p> <p>The binary is generated at <code>target/release/spooky</code>.</p> <p>Run tests (optional): </p><pre><code>cargo test\ncargo test -p spooky-edge --test lb_integration\n</code></pre><p></p> <p>System-wide installation: </p><pre><code>sudo install -m 755 target/release/spooky /usr/local/bin/spooky\n</code></pre><p></p>"},{"location":"getting-started/installation/#platform-specific-setup","title":"Platform-Specific Setup","text":""},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install build dependencies\nsudo apt update\nsudo apt install -y cmake build-essential pkg-config\n\n# Install Rust if not present\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n\n# Build and install\ngit clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\nsudo install -m 755 target/release/spooky /usr/local/bin/spooky\n</code></pre>"},{"location":"getting-started/installation/#centosrhel-8","title":"CentOS/RHEL 8+","text":"<pre><code># Install build dependencies\nsudo dnf groupinstall -y \"Development Tools\"\nsudo dnf install -y cmake pkgconfig\n\n# Install Rust if not present\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n\n# Build and install\ngit clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\nsudo install -m 755 target/release/spooky /usr/local/bin/spooky\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install dependencies via Homebrew\nbrew install cmake pkg-config rust\n\n# Build and install\ngit clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\nsudo install -m 755 target/release/spooky /usr/local/bin/spooky\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>Prerequisites: 1. Install Rust from rustup.rs 2. Install Visual Studio Build Tools with C++ support from Microsoft</p> <p>Build: </p><pre><code>git clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\n</code></pre><p></p> <p>Binary location: <code>target\\release\\spooky.exe</code></p>"},{"location":"getting-started/installation/#docker-deployment","title":"Docker Deployment","text":"<p>Dockerfile: </p><pre><code>FROM rust:1.70-slim as builder\n\nWORKDIR /app\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bookworm-slim\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y ca-certificates &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\nCOPY --from=builder /app/target/release/spooky /usr/local/bin/spooky\n\nEXPOSE 9889/udp\nCMD [\"spooky\"]\n</code></pre><p></p> <p>Build and run: </p><pre><code>docker build -t spooky:latest .\n\ndocker run -d \\\n  --name spooky \\\n  -p 9889:9889/udp \\\n  -v /path/to/config.yaml:/etc/spooky/config.yaml:ro \\\n  -v /path/to/certs:/etc/spooky/certs:ro \\\n  spooky:latest --config /etc/spooky/config.yaml\n</code></pre><p></p> <p>Using Docker Compose: </p><pre><code>version: '3.8'\nservices:\n  spooky:\n    build: .\n    ports:\n      - \"9889:9889/udp\"\n    volumes:\n      - ./config.yaml:/etc/spooky/config.yaml:ro\n      - ./certs:/etc/spooky/certs:ro\n    command: [\"--config\", \"/etc/spooky/config.yaml\"]\n    restart: unless-stopped\n</code></pre><p></p>"},{"location":"getting-started/installation/#installation-verification","title":"Installation Verification","text":"<pre><code># Verify binary is accessible\nspooky --version\n\n# Display help and available options\nspooky --help\n\n# Validate configuration syntax (startup validation happens before serving)\nspooky --config /path/to/config.yaml\n</code></pre> <p>Expected output from <code>spooky --version</code>: </p><pre><code>spooky 0.1.0\n</code></pre><p></p>"},{"location":"getting-started/installation/#post-installation-configuration","title":"Post-Installation Configuration","text":""},{"location":"getting-started/installation/#1-create-configuration-directory","title":"1. Create Configuration Directory","text":"<pre><code>sudo mkdir -p /etc/spooky\nsudo mkdir -p /etc/spooky/certs\nsudo chown -R $(whoami) /etc/spooky\n</code></pre>"},{"location":"getting-started/installation/#2-generate-tls-certificates","title":"2. Generate TLS Certificates","text":"<p>Self-signed certificates (development): </p><pre><code>openssl req -x509 -newkey rsa:4096 -nodes \\\n  -keyout /etc/spooky/certs/key.pem \\\n  -out /etc/spooky/certs/cert.pem \\\n  -days 365 \\\n  -subj \"/CN=proxy.example.com\"\n</code></pre><p></p> <p>For production certificates, see TLS Configuration.</p>"},{"location":"getting-started/installation/#3-create-base-configuration","title":"3. Create Base Configuration","text":"<p>Create <code>/etc/spooky/config.yaml</code>:</p> <pre><code>version: 1\n\nlisten:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"/etc/spooky/certs/cert.pem\"\n    key: \"/etc/spooky/certs/key.pem\"\n\nupstream:\n  default:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"backend-1\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\nlog:\n  level: info\n</code></pre>"},{"location":"getting-started/installation/#4-system-service-setup-linux","title":"4. System Service Setup (Linux)","text":"<p>Create <code>/etc/systemd/system/spooky.service</code>:</p> <pre><code>[Unit]\nDescription=Spooky HTTP/3 to HTTP/2 Proxy\nAfter=network.target\n\n[Service]\nType=simple\nUser=spooky\nGroup=spooky\nExecStart=/usr/local/bin/spooky --config /etc/spooky/config.yaml\nRestart=on-failure\nRestartSec=5s\n\n# Security hardening\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/var/log/spooky\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Create service user and enable: </p><pre><code>sudo useradd -r -s /bin/false spooky\nsudo systemctl daemon-reload\nsudo systemctl enable spooky.service\nsudo systemctl start spooky.service\n</code></pre><p></p>"},{"location":"getting-started/installation/#5-log-management","title":"5. Log Management","text":"<p>By default, Spooky logs to stderr (captured by journald under systemd). To write logs to a file instead, set <code>log.file.enabled: true</code> in your config:</p> <pre><code>log:\n  level: info\n  file:\n    enabled: true\n    path: /var/log/spooky/spooky.log\n</code></pre> <p>Configure log rotation for file-based logging:</p> <p>Create <code>/etc/logrotate.d/spooky</code>:</p> <pre><code>/var/log/spooky/*.log {\n    daily\n    rotate 14\n    compress\n    delaycompress\n    missingok\n    notifempty\n    create 0640 spooky spooky\n    sharedscripts\n    postrotate\n        systemctl restart spooky.service &gt;/dev/null 2&gt;&amp;1 || true\n    endscript\n}\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":"<p>Build fails with linker errors: - Ensure build tools are installed: <code>cmake</code>, <code>pkg-config</code>, C compiler - Update Rust toolchain: <code>rustup update</code></p> <p>Permission denied when binding to port: - Use port &gt; 1024, or grant capability: <code>sudo setcap CAP_NET_BIND_SERVICE=+eip /usr/local/bin/spooky</code> - Run as privileged user (not recommended for production)</p> <p>Certificate errors on startup: - Verify certificate and key paths in configuration - Check file permissions: certificates must be readable by the service user - Validate certificate format: <code>openssl x509 -in cert.pem -text -noout</code></p> <p>Binary not found after cargo install: - Add <code>~/.cargo/bin</code> to PATH: <code>export PATH=\"$HOME/.cargo/bin:$PATH\"</code> - Add to shell profile for persistence</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Reference - Complete configuration options</li> <li>TLS Setup Guide - Production certificate management</li> <li>Production Deployment - Production deployment best practices</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"getting-started/overview/","title":"Overview","text":""},{"location":"getting-started/overview/#overview","title":"Overview","text":"<p>Spooky is an HTTP/3 to HTTP/2 reverse proxy and load balancer. It terminates QUIC connections at the edge and forwards requests to HTTP/2 backends, enabling HTTP/3 client support without modifying existing infrastructure.</p>"},{"location":"getting-started/overview/#what-spooky-does","title":"What Spooky Does","text":"<p>Spooky bridges the gap between modern HTTP/3 clients and production HTTP/2 backends by:</p> <ul> <li>Terminating QUIC connections with TLS 1.3</li> <li>Converting HTTP/3 streams to HTTP/2 requests</li> <li>Distributing load across backend pools with active health checks</li> <li>Routing requests based on path prefix and hostname patterns</li> </ul>"},{"location":"getting-started/overview/#architecture","title":"Architecture","text":"<pre><code>HTTP/3 Client \u2192 QUIC/TLS \u2192 Spooky Edge \u2192 HTTP/2 \u2192 Backend Servers\n</code></pre> <p>Core Components:</p> <ul> <li>Edge: QUIC termination and HTTP/3 session management</li> <li>Bridge: Protocol conversion between HTTP/3 and HTTP/2</li> <li>Transport: HTTP/2 connection pooling and lifecycle management</li> <li>Load Balancer: Backend selection algorithms and health tracking</li> <li>Router: Path and host-based request routing</li> </ul>"},{"location":"getting-started/overview/#key-features","title":"Key Features","text":"<p>Protocol Support - HTTP/3 and QUIC (RFC 9114, RFC 9000) - TLS 1.3 with certificate chain validation - HTTP/2 backend connectivity</p> <p>Load Balancing - Random distribution - Round-robin rotation (default) - Consistent hashing with configurable virtual nodes - Global load balancing strategy (same for all upstreams)</p> <p>Routing - Path prefix matching with longest-match selection - Host-based routing - Multiple upstream pools with independent configurations</p> <p>Health Management - Active HTTP health checks with configurable intervals - Automatic backend removal on failure threshold - Cooldown periods for recovery</p>"},{"location":"getting-started/overview/#system-requirements","title":"System Requirements","text":"<p>Runtime Requirements: - Rust 1.85 or later (edition 2024) - Linux, macOS, or Windows - UDP port access for QUIC traffic - 256MB RAM minimum (1GB recommended for production)</p> <p>Build Dependencies:</p> <pre><code># Ubuntu/Debian\nsudo apt install cmake build-essential pkg-config\n\n# macOS\nbrew install cmake pkg-config\n</code></pre>"},{"location":"getting-started/overview/#quick-start","title":"Quick Start","text":"<pre><code># Clone and build\ngit clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\n\n# Generate certificates\nmake certs-selfsigned\n\n# Start proxy\n./target/release/spooky --config config/config.yaml\n</code></pre>"},{"location":"getting-started/overview/#configuration-example","title":"Configuration Example","text":"<p>Spooky uses YAML configuration with validation at startup:</p> <pre><code>version: 1\n\nlisten:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"certs/cert.pem\"\n    key: \"certs/key.pem\"\n\nupstream:\n  api_backend:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api-1\"\n        address: \"127.0.0.1:8001\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  default_backend:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"default-1\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n\nlog:\n  level: info\n</code></pre>"},{"location":"getting-started/overview/#testing-connectivity","title":"Testing Connectivity","text":"<p>Verify the proxy is functioning with an HTTP/3 client:</p> <pre><code>curl --http3-only -k \\\n  --resolve proxy.example.com:9889:127.0.0.1 \\\n  https://proxy.example.com:9889/api/health\n</code></pre>"},{"location":"getting-started/overview/#project-status","title":"Project Status","text":"<p>Spooky is experimental. Core features are implemented and functional, but the project is not production-ready. Expect rough edges, missing features, and breaking changes.</p> <p>Currently working:</p> <ul> <li>QUIC termination and HTTP/3 support</li> <li>HTTP/2 backend forwarding with connection pooling</li> <li>Multiple load balancing algorithms</li> <li>Active health checking with automatic recovery</li> <li>Path and host-based routing with upstream pools</li> </ul>"},{"location":"getting-started/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Complete installation instructions</li> <li>Configuration Reference - Full configuration documentation</li> <li>TLS Setup - Certificate generation and configuration</li> <li>Load Balancing Guide - Backend selection strategies</li> <li>Production Deployment - Production deployment guidelines</li> </ul>"},{"location":"protocols/http3/","title":"HTTP/3","text":""},{"location":"protocols/http3/#http3-protocol-overview","title":"HTTP/3 Protocol Overview","text":"<p>HTTP/3 is the third major version of the Hypertext Transfer Protocol, designed to improve performance and reliability by running over QUIC instead of TCP. It represents a fundamental shift in how HTTP traffic is transported while maintaining compatibility with existing HTTP semantics.</p>"},{"location":"protocols/http3/#evolution-of-http-transport","title":"Evolution of HTTP Transport","text":""},{"location":"protocols/http3/#http11-limitations","title":"HTTP/1.1 Limitations","text":"<p>HTTP/1.1 uses text-based, whitespace-delimited message framing that is human-readable but computationally expensive to parse. The protocol lacks native multiplexing support, requiring multiple TCP connections to achieve parallelism. This approach degrades congestion control effectiveness and increases connection overhead.</p> <p>Key characteristics: - Plain-text message format with verbose headers - One request per connection without pipelining support - Multiple connections required for concurrent requests - No header compression mechanism</p>"},{"location":"protocols/http3/#http2-improvements-and-remaining-issues","title":"HTTP/2 Improvements and Remaining Issues","text":"<p>HTTP/2 introduced binary framing and stream multiplexing over a single TCP connection, significantly improving efficiency. However, it inherited TCP's head-of-line blocking problem: packet loss on any stream stalls all multiplexed streams until retransmission occurs.</p> <p>Improvements over HTTP/1.1: - Binary framing layer for efficient parsing - Stream multiplexing with priority signaling - Header compression using HPACK - Server push capability</p> <p>Limitations: - TCP head-of-line blocking affects all streams - Connection establishment requires separate TCP and TLS handshakes - Limited resilience to network path changes</p>"},{"location":"protocols/http3/#quic-as-the-transport-foundation","title":"QUIC as the Transport Foundation","text":"<p>QUIC addresses HTTP/2's limitations by providing stream multiplexing at the transport layer with independent stream reliability. Built on UDP, QUIC integrates TLS 1.3 directly into the protocol, enabling faster connection establishment and 0-RTT resumption.</p> <p>QUIC features leveraged by HTTP/3: - Per-stream flow control and independent loss recovery - Connection-level congestion control - Integrated TLS 1.3 with single handshake - Connection migration support via connection identifiers - Reduced latency with 0-RTT data transmission</p> <p>HTTP/3 maps HTTP semantics onto QUIC streams, inheriting these transport-layer improvements while maintaining HTTP/2's design principles.</p>"},{"location":"protocols/http3/#http3-protocol-architecture","title":"HTTP/3 Protocol Architecture","text":""},{"location":"protocols/http3/#transport-layer","title":"Transport Layer","text":"<p>HTTP/3 operates exclusively over QUIC (RFC 9000), utilizing QUIC's stream multiplexing and flow control mechanisms. Each HTTP request/response pair maps to a single bidirectional QUIC stream, providing stream-level isolation and independent delivery guarantees.</p>"},{"location":"protocols/http3/#frame-structure","title":"Frame Structure","text":"<p>HTTP/3 communication uses typed frames transmitted within QUIC streams. Common frame types include:</p> <ul> <li>HEADERS: Carries HTTP header fields (compressed using QPACK)</li> <li>DATA: Conveys request or response payload</li> <li>SETTINGS: Communicates connection-level parameters</li> <li>PUSH_PROMISE: Initiates server push</li> <li>GOAWAY: Initiates graceful connection shutdown</li> </ul> <p>Frame types are variable-length encoded, with the frame type and length fields preceding the payload.</p>"},{"location":"protocols/http3/#stream-types","title":"Stream Types","text":"<p>HTTP/3 defines three stream types:</p> <ol> <li>Request streams (client-initiated bidirectional): Carry HTTP request/response exchanges</li> <li>Control stream (unidirectional): Manages connection-wide settings and parameters</li> <li>Push streams (server-initiated unidirectional): Deliver server-pushed responses</li> </ol>"},{"location":"protocols/http3/#requestresponse-model","title":"Request/Response Model","text":"<p>Each HTTP request/response cycle consumes one client-initiated bidirectional QUIC stream. The client sends HEADERS and optional DATA frames, then half-closes the stream. The server responds with HEADERS and DATA frames before closing its sending side.</p> <p>Stream independence ensures that packet loss on one stream does not block others, eliminating TCP-layer head-of-line blocking.</p>"},{"location":"protocols/http3/#server-push","title":"Server Push","text":"<p>HTTP/3 supports server push through the PUSH_PROMISE frame, which reserves a push stream identifier. The server then sends the pushed response on the corresponding push stream. Clients can limit or disable push using MAX_PUSH_ID and CANCEL_PUSH frames.</p>"},{"location":"protocols/http3/#header-compression-with-qpack","title":"Header Compression with QPACK","text":"<p>HTTP/3 replaces HTTP/2's HPACK compression with QPACK (RFC 9204), designed to handle QUIC's unordered stream delivery. QPACK maintains compression efficiency while allowing headers to be decoded independently when streams arrive out of order.</p> <p>QPACK features: - Dynamic table updates on a dedicated unidirectional stream - Reference tracking to prevent decoding dependencies - Configurable risk/compression tradeoff - Backward compatibility with HPACK concepts</p>"},{"location":"protocols/http3/#header-format-examples","title":"Header Format Examples","text":""},{"location":"protocols/http3/#http11-header-format","title":"HTTP/1.1 Header Format","text":"<pre><code>GET /index.html HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0\nAccept: text/html,application/xhtml+xml\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\n</code></pre> <p>HTTP/1.1 uses plain-text headers with CRLF delimiters. Each header field is a name-value pair separated by a colon.</p>"},{"location":"protocols/http3/#http2-header-format","title":"HTTP/2 Header Format","text":"<pre><code>HEADERS Frame (Stream 1):\n  :method = GET\n  :path = /index.html\n  :scheme = https\n  :authority = example.com\n  user-agent = Mozilla/5.0\n  accept = text/html,application/xhtml+xml\n  accept-encoding = gzip, deflate\n</code></pre> <p>HTTP/2 introduces pseudo-header fields (prefixed with <code>:</code>) for request metadata. Headers are encoded using HPACK and transmitted in a HEADERS frame.</p>"},{"location":"protocols/http3/#http3-header-format","title":"HTTP/3 Header Format","text":"<pre><code>HEADERS Frame (Stream 0):\n  :method = GET\n  :path = /index.html\n  :scheme = https\n  :authority = example.com\n  user-agent = Mozilla/5.0\n  accept = text/html,application/xhtml+xml\n  accept-encoding = gzip, deflate\n</code></pre> <p>HTTP/3 maintains HTTP/2's pseudo-header syntax but uses QPACK encoding instead of HPACK. The semantic meaning and structure are identical to HTTP/2.</p>"},{"location":"protocols/http3/#http2-vs-http3-comparison","title":"HTTP/2 vs HTTP/3 Comparison","text":"Feature HTTP/2 HTTP/3 Transport Protocol TCP QUIC (over UDP) Connection Establishment Separate TCP and TLS handshakes (2-3 RTT) Combined QUIC+TLS handshake (1-RTT) Header Compression HPACK QPACK Stream Multiplexing Application layer (within TCP connection) Transport layer (native QUIC streams) Head-of-Line Blocking TCP-layer blocking affects all streams Per-stream delivery (no cross-stream HoL) Connection Migration Not supported (TCP 4-tuple bound) Supported via connection IDs 0-RTT Support Limited (TLS 1.3 early data with constraints) Native 0-RTT with replay protection Header Field Syntax Pseudo-headers (<code>:method</code>, <code>:path</code>, <code>:scheme</code>) Same as HTTP/2 Server Push PUSH_PROMISE frame PUSH_PROMISE frame (same semantics) Flow Control Stream and connection level Stream and connection level"},{"location":"protocols/http3/#http3-implementation-in-spooky","title":"HTTP/3 Implementation in Spooky","text":"<p>Spooky implements HTTP/3 termination at the edge, accepting HTTP/3 client connections and translating them to HTTP/2 for backend forwarding. This approach enables HTTP/3 client support without requiring backend infrastructure changes.</p>"},{"location":"protocols/http3/#protocol-conversion","title":"Protocol Conversion","text":"<p>The Spooky bridge component handles bidirectional translation between HTTP/3 and HTTP/2:</p> <ol> <li> <p>Request path: HTTP/3 HEADERS and DATA frames are parsed, decompressed via QPACK, and re-encoded as HTTP/2 frames with HPACK compression for backend transmission.</p> </li> <li> <p>Response path: HTTP/2 responses from backends are decoded, headers are converted to QPACK format, and frames are transmitted over the client's HTTP/3 stream.</p> </li> </ol>"},{"location":"protocols/http3/#stream-mapping","title":"Stream Mapping","text":"<p>Each HTTP/3 client stream maps to a corresponding HTTP/2 stream on a backend connection. Stream lifecycle events (creation, data transfer, closure) are synchronized between protocols.</p>"},{"location":"protocols/http3/#connection-management","title":"Connection Management","text":"<p>Spooky maintains separate connection pools for client-facing HTTP/3 sessions and backend HTTP/2 connections. QUIC connection state is managed by the edge component, while HTTP/2 connection pooling is handled by the transport layer.</p>"},{"location":"protocols/http3/#feature-support","title":"Feature Support","text":"<ul> <li>Header compression: Full QPACK support for clients, HPACK for backends</li> <li>Flow control: QUIC stream and connection flow control enforced</li> <li>Server push: Not currently implemented (client-to-proxy only)</li> <li>Priority signaling: HTTP/3 priority frames are mapped to HTTP/2 priority when supported by backends</li> </ul>"},{"location":"protocols/http3/#performance-characteristics","title":"Performance Characteristics","text":"<p>HTTP/3 offers several performance advantages over HTTP/2:</p> <p>Reduced latency: Combined QUIC+TLS handshake reduces connection establishment time. 0-RTT resumption enables immediate data transmission for repeat connections.</p> <p>Improved loss resilience: Independent stream delivery prevents packet loss on one stream from blocking others. TCP's retransmission delays do not propagate across streams.</p> <p>Better mobile performance: Connection migration allows QUIC connections to survive network changes (Wi-Fi to cellular transitions) without interruption.</p> <p>Optimal congestion control: QUIC's congestion control operates at the connection level without TCP's limitations, enabling more accurate RTT estimation and loss detection.</p>"},{"location":"protocols/http3/#references","title":"References","text":"<ul> <li>RFC 9114: HTTP/3</li> <li>RFC 9000: QUIC Transport Protocol</li> <li>RFC 9204: QPACK Header Compression</li> <li>RFC 9218: Extensible Prioritization Scheme for HTTP</li> </ul>"},{"location":"protocols/quic/","title":"QUIC","text":""},{"location":"protocols/quic/#quic-protocol-overview","title":"QUIC Protocol Overview","text":"<p>QUIC (Quick UDP Internet Connections) is a multiplexed, secure transport protocol designed to address the performance limitations of TCP while maintaining reliability guarantees. Built on UDP, QUIC integrates transport and cryptographic handshakes, provides native stream multiplexing, and supports connection migration across network changes.</p> <p>Note: QUIC is a proper name, not an acronym, despite its origin as \"Quick UDP Internet Connections.\"</p>"},{"location":"protocols/quic/#protocol-fundamentals","title":"Protocol Fundamentals","text":""},{"location":"protocols/quic/#design-goals","title":"Design Goals","text":"<p>QUIC was designed to overcome specific limitations in TCP-based protocols:</p> <ol> <li> <p>Eliminate head-of-line blocking: TCP's byte-stream abstraction causes packet loss to block all multiplexed application streams. QUIC provides independent stream delivery.</p> </li> <li> <p>Reduce connection establishment latency: TCP and TLS negotiate separately, requiring multiple round trips. QUIC combines transport and cryptographic handshakes into a single exchange.</p> </li> <li> <p>Enable connection migration: TCP connections are bound to a 4-tuple (source IP, source port, destination IP, destination port). Network changes break connections. QUIC uses connection identifiers to survive NAT rebinding and network transitions.</p> </li> <li> <p>Modernize congestion control: QUIC's design allows rapid deployment of improved congestion control algorithms without requiring operating system updates.</p> </li> <li> <p>Provide encrypted transport by default: All QUIC payload data is encrypted using TLS 1.3, with only minimal connection metadata exposed.</p> </li> </ol>"},{"location":"protocols/quic/#transport-architecture","title":"Transport Architecture","text":"<p>QUIC operates as a connection-oriented protocol over UDP datagrams. Each UDP packet carries a QUIC packet containing one or more frames. Frames represent protocol operations: stream data transfer, acknowledgments, flow control updates, and connection management.</p> <p>Key architectural components:</p> <ul> <li>Connections: Stateful communication contexts identified by connection IDs</li> <li>Packets: UDP datagram payloads containing encrypted frames</li> <li>Frames: Typed protocol messages (stream data, control signals, etc.)</li> <li>Streams: Ordered byte-stream channels multiplexed within a connection</li> </ul>"},{"location":"protocols/quic/#connection-lifecycle","title":"Connection Lifecycle","text":""},{"location":"protocols/quic/#connection-establishment","title":"Connection Establishment","text":"<p>QUIC connections are established through a handshake that combines transport-layer and cryptographic negotiation. The process involves:</p> <p>1-RTT Handshake (First Connection):</p> <pre><code>Client                                      Server\n  |                                            |\n  |-- Initial[CRYPTO, PADDING] --------------&gt;|\n  |   (ClientHello, Transport Params)         |\n  |                                            |\n  |&lt;-- Initial[CRYPTO, ACK] -------------------|\n  |&lt;-- Handshake[CRYPTO] ----------------------|\n  |   (ServerHello, EncryptedExtensions,       |\n  |    Certificate, CertificateVerify,         |\n  |    Finished, Transport Params)             |\n  |                                            |\n  |-- Handshake[CRYPTO, ACK] ----------------&gt;|\n  |   (Finished)                               |\n  |                                            |\n  |&lt;== Application Data ======================|\n  |==&gt; Application Data ======================|\n</code></pre> <p>After the handshake completes, both endpoints can send application data. The entire process requires one round trip.</p> <p>0-RTT Handshake (Resumption):</p> <p>For resumed connections, clients can send application data in the first flight alongside the ClientHello, reducing latency to zero round trips at the cost of replay protection:</p> <pre><code>Client                                      Server\n  |                                            |\n  |-- Initial[CRYPTO] + 0-RTT[Stream Data] --&gt;|\n  |   (ClientHello, Application Data)          |\n  |                                            |\n  |&lt;-- Initial[CRYPTO] + Handshake[CRYPTO] ----|\n  |   (ServerHello, Finished)                  |\n  |                                            |\n  |==&gt; 1-RTT[Stream Data] =====================|\n  |&lt;== 1-RTT[Stream Data] =====================|\n</code></pre> <p>0-RTT data must be idempotent and replay-safe, as attackers can capture and replay the initial packet.</p>"},{"location":"protocols/quic/#transport-parameters","title":"Transport Parameters","text":"<p>During connection establishment, endpoints exchange transport parameters that define connection behavior:</p> <ul> <li><code>initial_max_data</code>: Connection-level flow control limit</li> <li><code>initial_max_stream_data_bidi_local/remote</code>: Per-stream flow control limits</li> <li><code>initial_max_streams_bidi/uni</code>: Maximum concurrent streams allowed</li> <li><code>max_idle_timeout</code>: Connection idle timeout duration</li> <li><code>max_udp_payload_size</code>: Maximum UDP payload the endpoint can receive</li> <li><code>active_connection_id_limit</code>: Number of connection IDs the peer can provide</li> </ul> <p>These parameters are immutable for the connection lifetime and must not change during resumption.</p>"},{"location":"protocols/quic/#connection-migration","title":"Connection Migration","text":"<p>QUIC connections are identified by connection IDs rather than network 4-tuples, enabling migration across network paths. Use cases include:</p> <ul> <li>NAT rebinding: UDP port changes due to NAT timeout</li> <li>Network transitions: Mobile device switching from Wi-Fi to cellular</li> <li>Load balancing: Server-initiated migration for capacity management</li> </ul> <p>Migration process:</p> <ol> <li>Client sends a packet from a new network path with a new source address</li> <li>Server validates the new path using a PATH_CHALLENGE frame</li> <li>Client responds with PATH_RESPONSE to prove path ownership</li> <li>Server begins sending packets to the new address</li> </ol> <p>Connection migration is client-initiated by default. Servers can only migrate by providing new connection IDs for clients to use.</p>"},{"location":"protocols/quic/#connection-termination","title":"Connection Termination","text":"<p>QUIC supports three termination mechanisms:</p> <p>1. Graceful Shutdown (CONNECTION_CLOSE):</p> <p>Either endpoint can send a CONNECTION_CLOSE frame to cleanly terminate the connection. The frame includes an error code and reason phrase. The peer acknowledges termination and both sides enter the closing state.</p> <p>2. Idle Timeout:</p> <p>If no packets are exchanged for the negotiated <code>max_idle_timeout</code> duration, the connection is silently closed without sending frames. This prevents resource exhaustion from abandoned connections.</p> <p>3. Stateless Reset:</p> <p>If an endpoint loses connection state (due to restart or migration), it cannot process incoming packets. The endpoint sends a stateless reset token to force the peer to abandon the connection immediately without further handshake.</p>"},{"location":"protocols/quic/#stream-multiplexing","title":"Stream Multiplexing","text":""},{"location":"protocols/quic/#stream-types","title":"Stream Types","text":"<p>QUIC provides four stream types based on directionality and initiator:</p> Type Initiated By Direction Use Case Bidirectional (client) Client Both HTTP request/response Bidirectional (server) Server Both Server-initiated interactions Unidirectional (client) Client Client\u2192Server Control streams, telemetry Unidirectional (server) Server Server\u2192Client Server push, control streams <p>Stream IDs encode the type and initiator in the two least-significant bits:</p> <ul> <li><code>0x00, 0x04, 0x08...</code>: Client-initiated bidirectional</li> <li><code>0x01, 0x05, 0x09...</code>: Server-initiated bidirectional</li> <li><code>0x02, 0x06, 0x0A...</code>: Client-initiated unidirectional</li> <li><code>0x03, 0x07, 0x0B...</code>: Server-initiated unidirectional</li> </ul>"},{"location":"protocols/quic/#stream-lifecycle","title":"Stream Lifecycle","text":"<p>Streams are created implicitly by sending a frame with the corresponding stream ID. No explicit open signal is required.</p> <p>State transitions:</p> <ol> <li>Idle: Stream ID has not been used</li> <li>Open: Data is being transmitted</li> <li>Half-closed (local): Local endpoint finished sending (sent FIN bit)</li> <li>Half-closed (remote): Remote endpoint finished sending (received FIN bit)</li> <li>Closed: Both sides finished sending</li> </ol> <p>Streams can be terminated early using RESET_STREAM (sending direction) and STOP_SENDING (receiving direction) frames.</p>"},{"location":"protocols/quic/#flow-control","title":"Flow Control","text":"<p>QUIC implements credit-based flow control at two levels:</p> <p>Stream-level flow control:</p> <p>Each stream has an independent flow control window. The receiver advertises the maximum byte offset it is willing to receive via MAX_STREAM_DATA frames. The sender must not exceed this limit.</p> <p>Connection-level flow control:</p> <p>The total bytes across all streams are subject to connection-level limits advertised via MAX_DATA frames. This prevents a single stream from consuming all connection resources.</p> <p>Flow control updates are sent asynchronously as data is consumed, allowing the sender to continue transmission without blocking.</p>"},{"location":"protocols/quic/#reliability-and-loss-recovery","title":"Reliability and Loss Recovery","text":""},{"location":"protocols/quic/#reliable-delivery","title":"Reliable Delivery","text":"<p>QUIC guarantees ordered, reliable delivery within each stream. Frames are assigned packet numbers (monotonically increasing per packet). The receiver acknowledges received packets using ACK frames, which include:</p> <ul> <li>Largest acknowledged packet number</li> <li>ACK delay (time between packet receipt and ACK generation)</li> <li>ACK ranges (compressed representation of received packets)</li> </ul>"},{"location":"protocols/quic/#loss-detection","title":"Loss Detection","text":"<p>QUIC uses acknowledgment-based loss detection. Packets are considered lost if:</p> <ol> <li>Reordering threshold: Three or more packets sent later have been acknowledged</li> <li>Time threshold: Sufficient time has elapsed since transmission without acknowledgment (typically 9/8 * smoothed RTT)</li> </ol> <p>Declared lost packets trigger retransmission of their frames.</p>"},{"location":"protocols/quic/#retransmission","title":"Retransmission","text":"<p>Lost frames are retransmitted in new packets with new packet numbers. QUIC does not retransmit packets verbatim; only the frames within them are resent. This decoupling allows acknowledgments to unambiguously identify which transmission was received.</p>"},{"location":"protocols/quic/#congestion-control","title":"Congestion Control","text":"<p>QUIC mandates congestion control but does not prescribe a specific algorithm. Implementations commonly use:</p> <ul> <li>NewReno: TCP NewReno adapted for QUIC (RFC 9002 default)</li> <li>CUBIC: More aggressive window growth for high-bandwidth paths</li> <li>BBR: Bottleneck bandwidth and round-trip propagation time estimation</li> </ul> <p>Congestion control operates per connection, not per stream. All streams share the congestion window and pacing budget.</p>"},{"location":"protocols/quic/#packet-structure","title":"Packet Structure","text":"<p>QUIC packets consist of a header and payload. Two header types exist:</p>"},{"location":"protocols/quic/#long-header-handshake-packets","title":"Long Header (Handshake Packets)","text":"<p>Used during connection establishment. Contains:</p> <ul> <li>Version field (4 bytes)</li> <li>Destination Connection ID Length + Destination Connection ID</li> <li>Source Connection ID Length + Source Connection ID</li> <li>Type-specific fields (token, length)</li> <li>Packet Number</li> <li>Encrypted payload</li> </ul> <p>Long header packets have types: Initial, 0-RTT, Handshake, and Retry.</p>"},{"location":"protocols/quic/#short-header-1-rtt-packets","title":"Short Header (1-RTT Packets)","text":"<p>Used after handshake completion. Contains:</p> <ul> <li>Spin bit (latency measurement)</li> <li>Destination Connection ID</li> <li>Packet Number</li> <li>Encrypted payload</li> </ul> <p>Short headers minimize overhead for long-lived connections.</p>"},{"location":"protocols/quic/#frame-types","title":"Frame Types","text":"<p>Common frame types:</p> <ul> <li>PADDING: Increases packet size for PMTU probing</li> <li>PING: Elicits acknowledgment without sending data</li> <li>ACK: Acknowledges received packets</li> <li>STREAM: Carries stream data with offset and length</li> <li>MAX_DATA / MAX_STREAM_DATA: Advertises flow control updates</li> <li>RESET_STREAM / STOP_SENDING: Aborts stream transmission</li> <li>CONNECTION_CLOSE: Terminates the connection</li> <li>PATH_CHALLENGE / PATH_RESPONSE: Validates network path during migration</li> </ul>"},{"location":"protocols/quic/#security-properties","title":"Security Properties","text":""},{"location":"protocols/quic/#encryption","title":"Encryption","text":"<p>QUIC uses TLS 1.3 for key derivation and encryption. Packet payloads are encrypted using AEAD algorithms (typically AES-128-GCM or ChaCha20-Poly1305). Packet headers are protected to prevent ossification by middleboxes.</p> <p>Encryption levels:</p> <ul> <li>Initial: Derived from well-known salt and client-chosen Destination Connection ID</li> <li>0-RTT: Derived from resumed session keys</li> <li>Handshake: Derived from ephemeral handshake keys</li> <li>1-RTT: Derived from final application traffic keys</li> </ul>"},{"location":"protocols/quic/#header-protection","title":"Header Protection","text":"<p>Packet numbers are encrypted to prevent middleboxes from tracking flows and inferring loss patterns. A sample from the encrypted payload is used to mask the packet number and flags.</p>"},{"location":"protocols/quic/#replay-protection","title":"Replay Protection","text":"<p>1-RTT data is protected by TLS's anti-replay mechanisms. 0-RTT data is inherently replayable and must be used only for idempotent operations. Servers can optionally reject 0-RTT to enforce strict replay protection.</p>"},{"location":"protocols/quic/#quic-implementation-in-spooky","title":"QUIC Implementation in Spooky","text":"<p>Spooky uses the <code>quiche</code> QUIC library for connection management and HTTP/3 framing. The implementation handles:</p>"},{"location":"protocols/quic/#connection-management","title":"Connection Management","text":"<ul> <li>Endpoint creation: Spooky binds to the configured UDP port and initializes the QUIC endpoint with TLS configuration</li> <li>Connection acceptance: Incoming QUIC connections are validated against TLS certificate requirements</li> <li>Idle timeout: Connections are closed after the configured idle period to reclaim resources</li> <li>Graceful shutdown: Spooky sends CONNECTION_CLOSE frames during shutdown to inform clients</li> </ul>"},{"location":"protocols/quic/#tls-integration","title":"TLS Integration","text":"<p>TLS 1.3 is mandatory for QUIC. Spooky loads certificate chains and private keys at startup:</p> <pre><code>let tls_config = rustls::ServerConfig::builder()\n    .with_safe_defaults()\n    .with_no_client_auth()\n    .with_single_cert(certs, private_key)?;\n</code></pre> <p>ALPN (Application-Layer Protocol Negotiation) is configured to advertise \"h3\" for HTTP/3:</p> <pre><code>tls_config.alpn_protocols = vec![b\"h3\".to_vec()];\n</code></pre>"},{"location":"protocols/quic/#stream-handling","title":"Stream Handling","text":"<p>HTTP/3 streams are mapped to QUIC streams:</p> <ul> <li>Request streams: Client-initiated bidirectional streams carry HTTP requests and responses</li> <li>Control stream: Unidirectional stream for HTTP/3 settings and control frames</li> <li>QPACK streams: Separate unidirectional streams for QPACK encoder/decoder communication</li> </ul> <p>Spooky's edge component accepts incoming streams and passes them to the bridge for HTTP/3 processing.</p>"},{"location":"protocols/quic/#flow-control_1","title":"Flow Control","text":"<p>Spooky configures QUIC transport parameters to balance memory usage and throughput:</p> <ul> <li>Connection-level flow control prevents excessive buffering across all streams</li> <li>Stream-level flow control limits individual stream memory consumption</li> <li>Defaults are tuned for typical web traffic patterns but can be adjusted for specific workloads</li> </ul>"},{"location":"protocols/quic/#congestion-control_1","title":"Congestion Control","text":"<p>Spooky uses the default NewReno congestion control provided by <code>quiche</code>. This choice balances fairness with TCP flows and predictable behavior across network conditions.</p>"},{"location":"protocols/quic/#performance-considerations","title":"Performance Considerations","text":""},{"location":"protocols/quic/#udp-socket-optimization","title":"UDP Socket Optimization","text":"<p>QUIC performance depends on efficient UDP socket handling:</p> <ul> <li>Receive buffer size: Increase <code>SO_RCVBUF</code> to reduce packet loss during bursts</li> <li>Send buffer size: Increase <code>SO_SNDBUF</code> to support large congestion windows</li> <li>GRO/GSO: Generic Receive/Send Offload reduces per-packet processing overhead on Linux</li> </ul>"},{"location":"protocols/quic/#packet-pacing","title":"Packet Pacing","text":"<p>Sending packets in bursts can trigger packet loss due to buffer overflow. QUIC implementations pace packet transmission based on the congestion window and RTT to smooth traffic.</p>"},{"location":"protocols/quic/#cpu-usage","title":"CPU Usage","text":"<p>QUIC's cryptographic operations (AEAD encryption/decryption, header protection) consume CPU. Performance tuning:</p> <ul> <li>Use hardware-accelerated cryptographic instructions (AES-NI)</li> <li>Batch packet processing to amortize per-packet overhead</li> <li>Offload TLS operations to dedicated threads if necessary</li> </ul>"},{"location":"protocols/quic/#memory-footprint","title":"Memory Footprint","text":"<p>Each QUIC connection maintains state for:</p> <ul> <li>Send and receive buffers for each stream</li> <li>Loss recovery metadata (sent packet information)</li> <li>Congestion control state (RTT estimates, congestion window)</li> </ul> <p>Spooky limits concurrent connections and streams to bound memory usage.</p>"},{"location":"protocols/quic/#comparison-with-tcp","title":"Comparison with TCP","text":"Feature TCP QUIC Transport Layer Kernel-space implementation User-space implementation Connection Establishment 3-way handshake + TLS (2-3 RTT) Combined handshake (1-RTT or 0-RTT) Stream Multiplexing Not supported (requires app layer) Native transport-level multiplexing Head-of-Line Blocking All streams blocked by packet loss Independent per-stream delivery Connection Migration Not supported Supported via connection IDs Congestion Control OS-dependent, slow to update User-space, rapid algorithm evolution Encryption Optional (TLS on top) Mandatory (integrated TLS 1.3) NAT Traversal Requires keep-alive mechanisms Built-in connection migration support Deployment Requires OS updates Application-level deployment"},{"location":"protocols/quic/#references","title":"References","text":"<ul> <li>RFC 9000: QUIC: A UDP-Based Multiplexed and Secure Transport</li> <li>RFC 9001: Using TLS to Secure QUIC</li> <li>RFC 9002: QUIC Loss Detection and Congestion Control</li> <li>RFC 8999: Version-Independent Properties of QUIC</li> <li>RFC 9221: An Unreliable Datagram Extension to QUIC</li> <li>RFC 9287: Greasing the QUIC Bit</li> </ul>"},{"location":"troubleshooting/common-issues/","title":"Troubleshooting","text":""},{"location":"troubleshooting/common-issues/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>Technical reference for diagnosing and resolving operational issues in Spooky HTTP/3 to HTTP/2 gateway deployments.</p>"},{"location":"troubleshooting/common-issues/#configuration-errors","title":"Configuration Errors","text":""},{"location":"troubleshooting/common-issues/#invalid-configuration-schema","title":"Invalid Configuration Schema","text":"<p>Error Messages: </p><pre><code>Invalid version: expected '1', found '2'\nInvalid protocol: expected 'http3', found 'http2'\nInvalid log level: debug-verbose\nInvalid load balancing type: 'weighted' for upstream 'api'\n</code></pre><p></p> <p>Root Causes: - Configuration schema version mismatch - Unsupported protocol specification - Invalid log level (valid: <code>whisper</code>, <code>haunt</code>, <code>spooky</code>, <code>scream</code>, <code>poltergeist</code>, <code>silence</code>, <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>off</code>) - Unsupported load balancing algorithm (valid: <code>random</code>, <code>round-robin</code>, <code>round_robin</code>, <code>rr</code>, <code>consistent-hash</code>, <code>consistent_hash</code>, <code>ch</code>)</p> <p>Diagnostic Commands: </p><pre><code># Validate YAML syntax\npython3 -c \"import yaml; yaml.safe_load(open('config.yaml'))\" 2&gt;&amp;1\n\n# Check configuration structure\ngrep -E \"^version:|^listen:|^upstream:\" config.yaml\n\n# Verify log level\ngrep \"log:\" -A 2 config.yaml\n\n# Check load balancing configuration\ngrep \"load_balancing:\" -A 2 config.yaml\n</code></pre><p></p> <p>Resolution: - Set <code>version: 1</code> in configuration file - Use <code>protocol: http3</code> for listen configuration - Correct log levels according to valid options - Update load balancing type to supported algorithms</p>"},{"location":"troubleshooting/common-issues/#listen-configuration-errors","title":"Listen Configuration Errors","text":"<p>Error Messages: </p><pre><code>Listen address is empty\nInvalid listen port: 0 (must be between 1 and 65535)\nInvalid listen port: 70000 (must be between 1 and 65535)\nFailed to bind UDP socket\n</code></pre><p></p> <p>Root Causes: - Missing or empty listen address - Port number outside valid range (1-65535) - Port already in use by another process - Insufficient privileges for privileged ports (&lt;1024)</p> <p>Diagnostic Commands: </p><pre><code># Check port availability (UDP)\nsudo ss -ulnp | grep :443\n\n# Identify process using port\nsudo lsof -i UDP:443\n\n# Check socket permissions\nsudo setcap -v 'cap_net_bind_service=+ep' /usr/local/bin/spooky\n\n# Verify listen configuration\ngrep -A 5 \"^listen:\" config.yaml\n</code></pre><p></p> <p>Resolution: </p><pre><code># Grant capability for privileged port binding\nsudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/spooky\n\n# Or bind to non-privileged port\nsed -i 's/port: 443/port: 8443/' config.yaml\n\n# Kill conflicting process\nsudo fuser -k 443/udp\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#upstream-pool-configuration-errors","title":"Upstream Pool Configuration Errors","text":"<p>Error Messages: </p><pre><code>No upstreams configured\nUpstream name is empty\nUpstream 'api' has no backends configured\nUpstream 'api' must have either 'host' or 'path_prefix' route matcher\nRoute path_prefix cannot be empty for upstream 'api'\nRoute path_prefix must start with '/' for upstream 'api': api/v1\n</code></pre><p></p> <p>Root Causes: - Empty upstream map in configuration - Missing route matching criteria (no <code>host</code> or <code>path_prefix</code>) - Invalid path prefix format (must start with <code>/</code>) - Empty backend list for upstream pool</p> <p>Diagnostic Commands: </p><pre><code># List configured upstreams\ngrep \"^upstream:\" -A 50 config.yaml | grep -E \"^  [a-z]\"\n\n# Check route configuration\nyq '.upstream[].route' config.yaml\n\n# Validate path prefixes\ngrep \"path_prefix:\" config.yaml\n</code></pre><p></p> <p>Resolution: </p><pre><code># Correct upstream configuration\nupstream:\n  api:\n    route:\n      host: \"api.example.com\"      # Host-based routing\n      path_prefix: \"/api\"          # Must start with /\n    load_balancing:\n      type: round-robin\n    backends:\n      - id: backend1\n        address: \"10.0.1.10:8080\"\n        weight: 100\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#backend-configuration-errors","title":"Backend Configuration Errors","text":"<p>Error Messages: </p><pre><code>Backend ID is empty in upstream 'api'\nBackend address is empty for backend 'backend1' in upstream 'api'\nBackend address '10.0.1.10' in upstream 'api' must be in host:port format\nBackend 'backend1' in upstream 'api' has invalid weight (0)\nHealth check interval is invalid (0) for backend 'backend1' in upstream 'api'\nHealth check timeout is invalid (0) for backend 'backend1' in upstream 'api'\nHealth check failure threshold is invalid (0) for backend 'backend1' in upstream 'api'\nHealth check success threshold is invalid (0) for backend 'backend1' in upstream 'api'\nHealth check cooldown is invalid (0) for backend 'backend1' in upstream 'api'\n</code></pre><p></p> <p>Root Causes: - Missing or malformed backend address (must be <code>host:port</code>) - Zero values for weight or health check parameters - Invalid health check configuration</p> <p>Diagnostic Commands: </p><pre><code># Validate backend addresses\ngrep \"address:\" config.yaml | grep -v \":\"\n\n# Check health check configuration\nyq '.upstream[].backends[].health_check' config.yaml\n\n# Verify backend weights\nyq '.upstream[].backends[].weight' config.yaml\n</code></pre><p></p> <p>Resolution: </p><pre><code># Correct backend configuration\nbackends:\n  - id: backend1\n    address: \"10.0.1.10:8080\"     # Must include port\n    weight: 100                    # Must be &gt; 0\n    health_check:\n      path: \"/health\"\n      interval: 5000               # Must be &gt; 0 (milliseconds)\n      timeout_ms: 2000             # Must be &gt; 0\n      failure_threshold: 3         # Must be &gt; 0\n      success_threshold: 2         # Must be &gt; 0\n      cooldown_ms: 10000           # Must be &gt; 0\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#tls-certificate-problems","title":"TLS Certificate Problems","text":""},{"location":"troubleshooting/common-issues/#certificate-file-access-errors","title":"Certificate File Access Errors","text":"<p>Error Messages: </p><pre><code>TLS certificate file does not exist: /etc/spooky/certs/server.crt\nTLS private key file does not exist: /etc/spooky/certs/server.key\nCannot read TLS certificate file '/etc/spooky/certs/server.crt': Permission denied\nCannot read TLS private key file '/etc/spooky/certs/server.key': Permission denied\nFailed to load certificate '/etc/spooky/certs/server.crt': No such file or directory\nFailed to load key '/etc/spooky/certs/server.key': error:02001002:system library:fopen:No such file or directory\n</code></pre><p></p> <p>Root Causes: - Certificate or key file path does not exist - Insufficient file permissions for Spooky process - Invalid PEM format - File ownership prevents access</p> <p>Diagnostic Commands: </p><pre><code># Verify file existence and permissions\nls -la /etc/spooky/certs/server.{crt,key}\n\n# Check file ownership\nstat /etc/spooky/certs/server.crt\n\n# Test read access\nsudo -u spooky cat /etc/spooky/certs/server.crt &gt; /dev/null\n\n# Validate PEM format\nopenssl x509 -in /etc/spooky/certs/server.crt -text -noout\nopenssl rsa -in /etc/spooky/certs/server.key -check -noout\n</code></pre><p></p> <p>Resolution: </p><pre><code># Fix file permissions\nsudo chown spooky:spooky /etc/spooky/certs/server.{crt,key}\nsudo chmod 644 /etc/spooky/certs/server.crt\nsudo chmod 600 /etc/spooky/certs/server.key\n\n# Verify certificate chain\nopenssl verify -CAfile ca.crt /etc/spooky/certs/server.crt\n\n# Test certificate-key pair match\ndiff &lt;(openssl x509 -in server.crt -noout -modulus | openssl md5) \\\n     &lt;(openssl rsa -in server.key -noout -modulus | openssl md5)\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#tls-handshake-failures","title":"TLS Handshake Failures","text":"<p>Error Messages: </p><pre><code>TLS configuration error during request processing: handshake failure\nFailed to load certificate: invalid certificate format\nQUIC recv failed: TlsFail\n</code></pre><p></p> <p>Root Causes: - Certificate-key mismatch - Expired certificate - Incomplete certificate chain - Unsupported TLS version - Client does not support required ALPN protocols (<code>h3</code>, <code>h3-29</code>)</p> <p>Diagnostic Commands: </p><pre><code># Check certificate expiration\nopenssl x509 -in server.crt -noout -dates\n\n# Verify certificate chain\nopenssl s_client -connect localhost:443 -showcerts &lt; /dev/null\n\n# Check ALPN negotiation (requires curl with HTTP/3 support)\ncurl --http3 -v https://localhost:443 2&gt;&amp;1 | grep -i alpn\n\n# Monitor TLS handshake packets\nsudo tcpdump -i any -n udp port 443 -X | grep -A 20 \"Initial\"\n</code></pre><p></p> <p>Resolution: </p><pre><code># Regenerate certificate with proper SAN\nopenssl req -new -x509 -days 365 -key server.key -out server.crt \\\n  -subj \"/CN=example.com\" \\\n  -addext \"subjectAltName=DNS:example.com,DNS:*.example.com\"\n\n# Ensure certificate chain is complete\ncat server.crt intermediate.crt &gt; fullchain.crt\n\n# Update configuration\nsed -i 's|cert: .*|cert: /etc/spooky/certs/fullchain.crt|' config.yaml\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#quic-connection-issues","title":"QUIC Connection Issues","text":""},{"location":"troubleshooting/common-issues/#connection-id-mismatch","title":"Connection ID Mismatch","text":"<p>Error Messages: </p><pre><code>Wrong QUIC HEADER\nNon-Initial packet for unknown connection, ignoring\nDropping packet for unknown connection from 192.168.1.10:52341 (DCID: a3f2...)\n</code></pre><p></p> <p>Root Causes: - Client using stale connection ID after server restart - Connection ID collision or corruption - NAT rebinding without proper migration support - Packet reordering or duplication</p> <p>Diagnostic Commands: </p><pre><code># Monitor connection IDs in logs\njournalctl -u spooky -f | grep -E \"DCID|SCID\"\n\n# Check active QUIC connections\nss -u -a | grep :443\n\n# Capture QUIC packets for analysis\nsudo tcpdump -i any -w quic.pcap udp port 443\ntshark -r quic.pcap -Y quic\n\n# Count connection errors\njournalctl -u spooky --since \"1 hour ago\" | grep -c \"Wrong QUIC HEADER\"\n</code></pre><p></p> <p>Resolution: - Issue is typically transient; clients will establish new connections - Ensure <code>set_disable_active_migration(true)</code> is set in QUIC config - Check for network middleboxes modifying UDP payloads - Increase <code>max_idle_timeout</code> if connections drop prematurely</p>"},{"location":"troubleshooting/common-issues/#version-negotiation-failures","title":"Version Negotiation Failures","text":"<p>Error Messages: </p><pre><code>Version negotiation failed: buffer too short\nFailed to send version negotiation: Network unreachable\n</code></pre><p></p> <p>Root Causes: - Client requesting unsupported QUIC version - MTU constraints preventing version negotiation packet transmission - Network path blocking UDP packets - Firewall stateful inspection interfering with QUIC</p> <p>Diagnostic Commands: </p><pre><code># Check supported QUIC version\njournalctl -u spooky | grep \"PROTOCOL_VERSION\"\n\n# Test MTU path\ntracepath -n -b 443 target-host\n\n# Verify UDP egress\nnc -u -v -w 1 target-host 443 &lt; /dev/null\n\n# Monitor version negotiation packets\nsudo tcpdump -i any udp port 443 -v | grep -i version\n</code></pre><p></p> <p>Resolution: </p><pre><code># Configure smaller UDP payload size\n# Edit config or quiche parameters:\n# set_max_recv_udp_payload_size(1200)\n# set_max_send_udp_payload_size(1200)\n\n# Adjust firewall rules\nsudo iptables -I INPUT -p udp --dport 443 -j ACCEPT\nsudo iptables -I OUTPUT -p udp --sport 443 -j ACCEPT\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#quic-timeout-and-idle-connections","title":"QUIC Timeout and Idle Connections","text":"<p>Error Messages: </p><pre><code>QUIC recv failed: Done\nConnection closed, not storing\n</code></pre><p></p> <p>Root Causes: - Idle timeout exceeded (default 5000ms in Spooky) - Network path timeout - Client terminated connection without proper close - NAT binding expired</p> <p>Diagnostic Commands: </p><pre><code># Check connection lifetimes\njournalctl -u spooky | grep -E \"Creating new connection|Connection closed\" | tail -20\n\n# Monitor timeout events\njournalctl -u spooky -f | grep \"on_timeout\"\n\n# Analyze connection duration distribution\njournalctl -u spooky --since \"1 hour ago\" | \\\n  grep \"Creating new connection\" | wc -l\n\n# Check NAT timeout settings (if behind NAT)\ncat /proc/sys/net/netfilter/nf_conntrack_udp_timeout\n</code></pre><p></p> <p>Resolution: </p><pre><code>// Adjust idle timeout in quiche configuration\nquic_config.set_max_idle_timeout(10000);  // Increase to 10 seconds\n\n// Tune UDP stream limits\nquic_config.set_initial_max_streams_bidi(200);\nquic_config.set_initial_max_streams_uni(200);\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#backend-connectivity-failures","title":"Backend Connectivity Failures","text":""},{"location":"troubleshooting/common-issues/#unknown-backend-errors","title":"Unknown Backend Errors","text":"<p>Error Messages: </p><pre><code>No route found for path: /api/users (host: Some(\"api.example.com\"))\nUpstream pool not found for: api\nunknown backend: 10.0.1.10:8080\n</code></pre><p></p> <p>Root Causes: - Request path/host does not match any configured upstream route - Upstream pool not properly initialized - Backend not registered in H2 connection pool - Route matching logic precedence issue</p> <p>Diagnostic Commands: </p><pre><code># List configured routes\nyq '.upstream[] | {route}' config.yaml\n\n# Test route matching\njournalctl -u spooky -f | grep \"No route found\"\n\n# Verify H2 pool initialization\njournalctl -u spooky --since \"10 minutes ago\" | grep -i \"pool\"\n\n# Check backend registration\nss -t | grep :8080 | wc -l\n</code></pre><p></p> <p>Resolution: </p><pre><code># Ensure proper route specificity (longest prefix matching)\nupstream:\n  api_v2:\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/api/v2\"   # More specific\n    backends: [...]\n\n  api_v1:\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/api\"      # Less specific\n    backends: [...]\n\n  default:\n    route:\n      path_prefix: \"/\"         # Catch-all\n    backends: [...]\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#http2-connection-pool-errors","title":"HTTP/2 Connection Pool Errors","text":"<p>Error Messages: </p><pre><code>Transport error: send: connection error detected: frame with invalid size\nTransport error: send: connection closed\nTransport error: body: stream error received: stream no longer needed\nBackend timeout\n</code></pre><p></p> <p>Root Causes: - Backend closed HTTP/2 connection unexpectedly - H2 frame size violation - Backend service crashed or restarted - Connection pool exhaustion (&gt;64 inflight requests per backend) - Network timeout (2s default in Spooky)</p> <p>Diagnostic Commands: </p><pre><code># Monitor H2 connection errors\njournalctl -u spooky -f | grep \"Transport error\"\n\n# Check backend H2 support\ncurl -I --http2 http://10.0.1.10:8080/\n\n# Test backend health endpoint\ncurl -v http://10.0.1.10:8080/health\n\n# Monitor connection pool saturation\njournalctl -u spooky | grep \"semaphore closed\"\n\n# Check backend service status\nsystemctl status backend-service\n</code></pre><p></p> <p>Resolution: </p><pre><code># Increase backend timeout if needed\n# Edit quic_listener.rs: BACKEND_TIMEOUT = Duration::from_secs(5);\n\n# Adjust max inflight requests per backend\n# Edit quic_listener.rs: MAX_INFLIGHT_PER_BACKEND = 128;\n\n# Restart backend service\nsudo systemctl restart backend-service\n\n# Monitor backend connection states\nwatch -n 1 'ss -t -a | grep :8080'\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#backend-health-check-failures","title":"Backend Health Check Failures","text":"<p>Error Messages: </p><pre><code>Backend 10.0.1.10:8080 became unhealthy\nHealth checks disabled: no Tokio runtime available\n</code></pre><p></p> <p>Root Causes: - Backend failing health check endpoint - Health check timeout too aggressive - Backend intermittently unavailable - Network path to backend unreliable - Health check threshold too sensitive</p> <p>Diagnostic Commands: </p><pre><code># Monitor health transitions\njournalctl -u spooky -f | grep -E \"became healthy|became unhealthy\"\n\n# Manual health check\ncurl -w \"@-\" -o /dev/null -s http://10.0.1.10:8080/health &lt;&lt;&lt; \\\n  'time_total: %{time_total}s\\nhttp_code: %{http_code}\\n'\n\n# Check health check configuration\nyq '.upstream[].backends[].health_check' config.yaml\n\n# Monitor backend response times\nhttping -c 10 http://10.0.1.10:8080/health\n</code></pre><p></p> <p>Resolution: </p><pre><code># Adjust health check parameters for stability\nbackends:\n  - id: backend1\n    address: \"10.0.1.10:8080\"\n    health_check:\n      path: \"/health\"\n      interval: 10000           # Increase interval\n      timeout_ms: 5000          # Increase timeout\n      failure_threshold: 5      # Require more failures\n      success_threshold: 2      # Require consecutive successes\n      cooldown_ms: 30000        # Longer cooldown\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#load-balancing-issues","title":"Load Balancing Issues","text":""},{"location":"troubleshooting/common-issues/#no-healthy-backends-available","title":"No Healthy Backends Available","text":"<p>Error Messages: </p><pre><code>no healthy servers\nno servers configured for upstream\n</code></pre><p></p> <p>Root Causes: - All backends failed health checks - Empty backend list for upstream - Backends in cooldown period after failures - Circuit breaker triggered</p> <p>Diagnostic Commands: </p><pre><code># Check backend health status\njournalctl -u spooky | grep -E \"became healthy|became unhealthy\" | tail -20\n\n# Monitor 503 Service Unavailable responses\njournalctl -u spooky | grep \"status 503\"\n\n# Count healthy vs total backends per upstream\nyq '.upstream[].backends | length' config.yaml\n\n# Check recent health transitions\njournalctl -u spooky --since \"5 minutes ago\" | grep \"Backend\"\n</code></pre><p></p> <p>Resolution: </p><pre><code># Verify backend services are running\nfor backend in 10.0.1.10:8080 10.0.1.11:8080; do\n  echo -n \"$backend: \"\n  curl -s -o /dev/null -w \"%{http_code}\" http://$backend/health || echo \"FAIL\"\n  echo\ndone\n\n# Temporarily disable health checks for debugging\n# Set failure_threshold very high in config.yaml\n\n# Restart Spooky to reset health state\nsudo systemctl restart spooky\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#uneven-load-distribution","title":"Uneven Load Distribution","text":"<p>Symptoms: - One backend receives disproportionate traffic - Round-robin not cycling through backends - Consistent hash not distributing evenly</p> <p>Root Causes: - Backend weight misconfiguration - Inconsistent hash key selection (always same key) - Some backends marked unhealthy - Hash ring replica count too low for consistent-hash</p> <p>Diagnostic Commands: </p><pre><code># Analyze backend selection distribution\njournalctl -u spooky | grep \"Selected backend\" | \\\n  awk '{print $(NF-2)}' | sort | uniq -c\n\n# Check backend weights\nyq '.upstream[].backends[] | \"\\(.id): \\(.weight)\"' config.yaml\n\n# Monitor load balancing algorithm\njournalctl -u spooky | grep \"via round-robin\\|via consistent-hash\\|via random\"\n\n# Check hash key consistency\njournalctl -u spooky | grep \"request_hash_key\"\n</code></pre><p></p> <p>Resolution: </p><pre><code># Ensure proper weight distribution\nbackends:\n  - id: backend1\n    address: \"10.0.1.10:8080\"\n    weight: 100\n  - id: backend2\n    address: \"10.0.1.11:8080\"\n    weight: 100    # Equal weight for even distribution\n\n# For consistent-hash, increase replica count\n# Edit lb/src/lib.rs: DEFAULT_REPLICAS = 128;\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#performance-problems","title":"Performance Problems","text":""},{"location":"troubleshooting/common-issues/#high-latency","title":"High Latency","text":"<p>Symptoms: - <code>latency_ms</code> in logs consistently &gt;1000ms - Slow response times reported by clients - Backend timeout errors (503 status)</p> <p>Root Causes: - Backend processing delay - Network congestion - Connection pool saturation - CPU saturation on Spooky host - Inefficient load balancing</p> <p>Diagnostic Commands: </p><pre><code># Analyze latency distribution\njournalctl -u spooky --since \"1 hour ago\" | \\\n  grep \"latency_ms\" | \\\n  awk '{print $(NF)}' | \\\n  sort -n | \\\n  awk '{sum+=$1; arr[NR]=$1} END {\n    print \"min:\", arr[1];\n    print \"p50:\", arr[int(NR*0.5)];\n    print \"p95:\", arr[int(NR*0.95)];\n    print \"p99:\", arr[int(NR*0.99)];\n    print \"max:\", arr[NR];\n    print \"avg:\", sum/NR;\n  }'\n\n# Monitor CPU usage\ntop -b -n 1 | grep spooky\n\n# Check connection pool contention\njournalctl -u spooky | grep \"semaphore\" | tail -20\n\n# Measure backend response time directly\ntime curl http://10.0.1.10:8080/api/test\n</code></pre><p></p> <p>Resolution: </p><pre><code># Increase backend timeout if backends are slow but reliable\n# Edit BACKEND_TIMEOUT in quic_listener.rs\n\n# Scale backend capacity\n# Add more backends to upstream pool\n\n# Increase connection pool size\n# Edit MAX_INFLIGHT_PER_BACKEND in quic_listener.rs\n\n# Optimize backend application\n# Profile and optimize backend code\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#memory-growth","title":"Memory Growth","text":"<p>Symptoms: - RSS memory continuously increasing - Out of memory errors - System swapping</p> <p>Root Causes: - Connection leak (connections not properly closed) - Request/response body buffering - Metrics accumulation - QUIC connection state not cleaned up</p> <p>Diagnostic Commands: </p><pre><code># Monitor memory usage over time\nwhile true; do\n  ps -p $(pgrep spooky) -o pid,vsz,rss,cmd | tail -1\n  sleep 10\ndone\n\n# Check connection count\nss -u | grep -c :443\n\n# Analyze memory map\nsudo pmap -x $(pgrep spooky)\n\n# Check for file descriptor leaks\nls -l /proc/$(pgrep spooky)/fd | wc -l\n</code></pre><p></p> <p>Resolution: </p><pre><code># Restart Spooky periodically (temporary mitigation)\nsudo systemctl restart spooky\n\n# Monitor connection cleanup\njournalctl -u spooky -f | grep \"Connection closed\"\n\n# Reduce max idle timeout\n# Edit quic_config.set_max_idle_timeout(3000);\n\n# Limit connection count\n# Implement connection limit in accept logic\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#udp-packet-loss","title":"UDP Packet Loss","text":"<p>Symptoms: - Retransmissions in QUIC logs - Client timeout errors - Degraded throughput</p> <p>Root Causes: - Network congestion - UDP buffer overflow (receive buffer too small) - Firewall dropping packets - MTU fragmentation</p> <p>Diagnostic Commands: </p><pre><code># Check UDP buffer sizes\nsysctl net.core.rmem_max net.core.rmem_default\nsysctl net.core.wmem_max net.core.wmem_default\n\n# Monitor UDP statistics\nnetstat -su | grep -E \"packet receive errors|receive buffer errors\"\n\n# Capture packet loss\nsudo tcpdump -i any -c 1000 udp port 443 -w capture.pcap\ntshark -r capture.pcap -q -z io,stat,1\n\n# Check interface statistics\nip -s link show eth0\n</code></pre><p></p> <p>Resolution: </p><pre><code># Increase UDP buffer sizes\nsudo sysctl -w net.core.rmem_max=26214400\nsudo sysctl -w net.core.wmem_max=26214400\nsudo sysctl -w net.core.rmem_default=26214400\nsudo sysctl -w net.core.wmem_default=26214400\n\n# Make permanent\necho \"net.core.rmem_max=26214400\" | sudo tee -a /etc/sysctl.conf\necho \"net.core.wmem_max=26214400\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n\n# Reduce UDP payload size\n# Edit quic_config.set_max_recv_udp_payload_size(1350);\n</code></pre><p></p>"},{"location":"troubleshooting/common-issues/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/common-issues/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code># config.yaml\nlog:\n  level: haunt  # debug level\n</code></pre> <pre><code># Restart to apply\nsudo systemctl restart spooky\n\n# Monitor debug logs\njournalctl -u spooky -f --output=cat\n</code></pre>"},{"location":"troubleshooting/common-issues/#analyze-request-flow","title":"Analyze Request Flow","text":"<pre><code># Trace specific request path\njournalctl -u spooky | grep -E \"HTTP/3 request|Selected backend|Upstream.*status\" | \\\n  grep \"/api/users\"\n\n# Monitor complete request lifecycle\njournalctl -u spooky -f | \\\n  grep -E \"Creating new connection|HTTP/3 request|Selected backend|status.*latency_ms|Connection closed\"\n</code></pre>"},{"location":"troubleshooting/common-issues/#packet-capture-analysis","title":"Packet Capture Analysis","text":"<pre><code># Capture QUIC traffic\nsudo tcpdump -i any -w spooky.pcap udp port 443\n\n# Analyze with tshark\ntshark -r spooky.pcap -Y quic -T fields \\\n  -e frame.time -e ip.src -e ip.dst -e quic.header_form\n\n# Decrypt QUIC (requires SSLKEYLOGFILE)\nSSLKEYLOGFILE=/tmp/keys.log curl --http3 https://localhost:443/\ntshark -r spooky.pcap -o tls.keylog_file:/tmp/keys.log -Y http3\n</code></pre>"},{"location":"troubleshooting/common-issues/#performance-profiling","title":"Performance Profiling","text":"<pre><code># CPU profiling with perf\nsudo perf record -F 99 -p $(pgrep spooky) -g -- sleep 30\nsudo perf report --stdio | head -50\n\n# Flamegraph generation\nsudo perf record -F 99 -p $(pgrep spooky) -g -- sleep 30\nsudo perf script | stackcollapse-perf.pl | flamegraph.pl &gt; flamegraph.svg\n\n# Memory profiling (if built with jemalloc)\nexport MALLOC_CONF=prof:true,prof_prefix:/tmp/jeprof\nsudo systemctl restart spooky\n# Send traffic, then analyze with jeprof\n</code></pre>"},{"location":"troubleshooting/common-issues/#common-error-reference","title":"Common Error Reference","text":"Error Message HTTP Status Cause Resolution <code>invalid request</code> 400 Malformed HTTP/3 headers Check client request format <code>no servers configured for upstream</code> 503 Empty backend list Add backends to upstream config <code>no healthy servers</code> 503 All backends unhealthy Check backend health, adjust thresholds <code>invalid server</code> 503 Backend index out of bounds Configuration reload race condition <code>upstream error</code> 502 Backend connection failed Verify backend connectivity <code>upstream timeout</code> 503 Backend exceeded 2s timeout Increase BACKEND_TIMEOUT or optimize backend <code>internal server error</code> 500 TLS configuration error Check certificate/key files <code>Wrong QUIC HEADER</code> (dropped) Malformed QUIC packet Check for network corruption <code>No route found for path</code> (internal) No matching upstream route Add route configuration <code>Upstream pool not found</code> (internal) Pool initialization failure Check logs for startup errors"},{"location":"troubleshooting/common-issues/#support-and-escalation","title":"Support and Escalation","text":"<p>When reporting issues, include:</p> <pre><code># 1. Version information\nspooky --version\n\n# 2. Configuration (sanitized)\nyq eval 'del(.listen.tls.key, .listen.tls.cert)' config.yaml\n\n# 3. System information\nuname -a\ncat /etc/os-release\n\n# 4. Error logs (last 100 lines)\njournalctl -u spooky --no-pager -n 100 --since \"1 hour ago\"\n\n# 5. Resource utilization\nps aux | grep spooky\nss -u | grep -c :443\nfree -h\n\n# 6. Network diagnostics\nss -ulnp | grep spooky\nsudo iptables -L -n -v | grep 443\n</code></pre> <p>For production incidents, capture diagnostic bundle:</p> <pre><code>#!/bin/bash\nmkdir -p spooky-diagnostics\ncd spooky-diagnostics\n\nspooky --version &gt; version.txt\nuname -a &gt; system.txt\njournalctl -u spooky --no-pager -n 500 &gt; logs.txt\nyq eval 'del(.listen.tls.key, .listen.tls.cert)' ../config.yaml &gt; config.yaml\nps aux | grep spooky &gt; processes.txt\nss -tulnp &gt; sockets.txt\nfree -h &gt; memory.txt\nsudo tcpdump -i any -c 100 -w capture.pcap udp port 443\n\ncd ..\ntar czf spooky-diagnostics-$(date +%Y%m%d-%H%M%S).tar.gz spooky-diagnostics/\n</code></pre>"},{"location":"tutorials/quickstart/","title":"Quick Start","text":""},{"location":"tutorials/quickstart/#quickstart-guide","title":"Quickstart Guide","text":"<p>This guide demonstrates how to deploy a working Spooky HTTP/3 proxy in under 10 minutes. You will set up a basic proxy configuration, generate self-signed certificates, and verify HTTP/3 connectivity to a backend service.</p>"},{"location":"tutorials/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.85 or later installed (edition 2024)</li> <li>Basic familiarity with command-line tools</li> <li>An HTTP/2 backend service running locally (or use the example backend provided)</li> <li>UDP port 9889 available for QUIC traffic</li> </ul>"},{"location":"tutorials/quickstart/#step-1-build-spooky","title":"Step 1: Build Spooky","text":"<p>Clone the repository and build the release binary:</p> <pre><code>git clone https://github.com/nishujangra/spooky.git\ncd spooky\ncargo build --release\n</code></pre> <p>The compiled binary will be located at <code>target/release/spooky</code>. Build time is typically 2-5 minutes depending on your system.</p>"},{"location":"tutorials/quickstart/#step-2-generate-self-signed-certificates","title":"Step 2: Generate Self-Signed Certificates","text":"<p>QUIC requires TLS 1.3, so you need certificate and key files. For testing purposes, generate a self-signed certificate:</p> <pre><code>mkdir -p certs\nopenssl req -x509 -newkey rsa:4096 -nodes \\\n  -keyout certs/key.pem \\\n  -out certs/cert.pem \\\n  -days 365 \\\n  -subj \"/CN=localhost\"\n</code></pre> <p>This creates: - <code>certs/cert.pem</code>: The TLS certificate - <code>certs/key.pem</code>: The private key</p> <p>Note: For production deployments, use certificates from a trusted Certificate Authority (CA). See TLS Configuration for production certificate setup.</p>"},{"location":"tutorials/quickstart/#step-3-start-a-test-backend-server","title":"Step 3: Start a Test Backend Server","text":"<p>You need an HTTP/2 backend for Spooky to forward traffic to. If you don't have one running, use the provided HTTP/2 test backend:</p> <pre><code># Using Spooky's built-in HTTP/2 test backend\ncargo run --bin h2_backend -- --port 8080\n</code></pre> <p>This starts an HTTP/2-only server on <code>127.0.0.1:8080</code>. Spooky requires HTTP/2 backends - HTTP/1.1 backends are not supported.</p>"},{"location":"tutorials/quickstart/#step-4-create-configuration-file","title":"Step 4: Create Configuration File","text":"<p>Create a minimal configuration file named <code>config.yaml</code>:</p> <pre><code>version: 1\n\nlisten:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"certs/cert.pem\"\n    key: \"certs/key.pem\"\n\nupstream:\n  default:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"local-backend\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n        health_check:\n          path: \"/\"\n          interval: 5000\n          timeout_ms: 2000\n          success_threshold: 2\n          failure_threshold: 3\n\nlog:\n  level: info\n</code></pre> <p>This configuration: - Listens for HTTP/3 connections on UDP port 9889 - Uses the generated self-signed certificates - Forwards all requests to <code>127.0.0.1:8080</code> using random load balancing - Performs health checks every 5 seconds on the backend</p>"},{"location":"tutorials/quickstart/#step-5-start-spooky","title":"Step 5: Start Spooky","text":"<p>Launch the proxy with the configuration file:</p> <pre><code>./target/release/spooky --config config.yaml\n</code></pre> <p>Expected output:</p> <pre><code>[INFO] Loading configuration from config.yaml\n[INFO] Starting Spooky HTTP/3 proxy\n[INFO] Listening on 0.0.0.0:9889 (HTTP/3)\n[INFO] Backend local-backend (127.0.0.1:8080) marked healthy\n[INFO] Proxy started successfully\n</code></pre> <p>The proxy is now accepting HTTP/3 connections on port 9889 and forwarding them to the backend on port 8080.</p>"},{"location":"tutorials/quickstart/#step-6-test-connectivity","title":"Step 6: Test Connectivity","text":"<p>Verify that HTTP/3 requests are being proxied correctly. You will need an HTTP/3-capable client such as curl with HTTP/3 support.</p>"},{"location":"tutorials/quickstart/#using-curl-with-http3","title":"Using curl with HTTP/3","text":"<p>If you have curl compiled with HTTP/3 support:</p> <pre><code>curl --http3-only -k https://localhost:9889/\n</code></pre> <p>The <code>-k</code> flag bypasses certificate validation for self-signed certificates. You should see the response from your backend server.</p>"},{"location":"tutorials/quickstart/#using-curl-with-alt-svc-discovery","title":"Using curl with Alt-Svc Discovery","text":"<p>For a more realistic test that mimics browser behavior:</p> <pre><code>curl -k \\\n  --resolve localhost:9889:127.0.0.1 \\\n  https://localhost:9889/\n</code></pre> <p>Verify HTTP/3 connectivity by forcing HTTP/3-only requests:</p> <pre><code>curl -k --http3-only https://localhost:9889/\n</code></pre> <p>If successful, you should receive a response from your backend. HTTP/3 connectivity is confirmed when the request succeeds (Spooky doesn't advertise Alt-Svc headers).</p>"},{"location":"tutorials/quickstart/#using-a-custom-http3-client","title":"Using a Custom HTTP/3 Client","text":"<p>If you don't have HTTP/3 support in curl, you can use other clients:</p> <p>Using h3i (HTTP/3 interactive client):</p> <pre><code>cargo install h3i\nh3i https://localhost:9889/ --insecure\n</code></pre> <p>Using qh3 (QUIC HTTP/3 client):</p> <pre><code>git clone https://github.com/cloudflare/quiche.git\ncd quiche/tools/apps\ncargo build --release\n./target/release/quiche-client https://localhost:9889/ --no-verify\n</code></pre>"},{"location":"tutorials/quickstart/#step-7-verify-backend-forwarding","title":"Step 7: Verify Backend Forwarding","text":"<p>Check that requests are being forwarded to the backend. In the terminal running Spooky, you should see log entries indicating request handling:</p> <pre><code>[INFO] QUIC connection established from 127.0.0.1:55420\n[INFO] HTTP/3 stream 0: GET /\n[INFO] Forwarding to backend local-backend (127.0.0.1:8080)\n[INFO] Response 200 OK forwarded to client\n</code></pre> <p>In the backend server terminal, verify that HTTP requests are being received.</p>"},{"location":"tutorials/quickstart/#step-8-test-path-based-routing-optional","title":"Step 8: Test Path-Based Routing (Optional)","text":"<p>To demonstrate routing capabilities, modify the configuration to add multiple upstream pools:</p> <pre><code>upstream:\n  api_backend:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api-server\"\n        address: \"127.0.0.1:8001\"\n        weight: 100\n\n  default_backend:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"default-server\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n</code></pre> <p>Restart Spooky with the updated configuration. Requests to <code>/api/*</code> will route to port 8001, while all other requests route to port 8080.</p> <p>Test the routing:</p> <pre><code># Routes to default backend (port 8080)\ncurl --http3-only -k https://localhost:9889/\n\n# Routes to API backend (port 8001)\ncurl --http3-only -k https://localhost:9889/api/users\n</code></pre>"},{"location":"tutorials/quickstart/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorials/quickstart/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 9889 is already bound:</p> <pre><code>Error: Address already in use (os error 98)\n</code></pre> <p>Solution: Either stop the conflicting process or change the port in <code>config.yaml</code>.</p>"},{"location":"tutorials/quickstart/#backend-connection-refused","title":"Backend Connection Refused","text":"<p>If Spooky cannot connect to the backend:</p> <pre><code>[ERROR] Failed to connect to backend local-backend: Connection refused\n</code></pre> <p>Solution: Ensure the backend service is running on the configured address and port.</p>"},{"location":"tutorials/quickstart/#certificate-errors","title":"Certificate Errors","text":"<p>If the certificate is not found:</p> <pre><code>[ERROR] Failed to load TLS certificate: No such file or directory\n</code></pre> <p>Solution: Verify that the certificate paths in <code>config.yaml</code> are correct and the files exist.</p>"},{"location":"tutorials/quickstart/#health-check-failures","title":"Health Check Failures","text":"<p>If backends are marked unhealthy:</p> <pre><code>[WARN] Backend local-backend health check failed: timeout\n</code></pre> <p>Solution: Ensure the health check path exists on the backend and responds within the timeout period (default 2 seconds).</p>"},{"location":"tutorials/quickstart/#next-steps","title":"Next Steps","text":"<p>You now have a working HTTP/3 to HTTP/2 proxy. To further configure and optimize Spooky:</p> <ul> <li>Configuration Reference - Complete configuration options including advanced load balancing and routing</li> <li>TLS Setup - Configure production TLS certificates with Let's Encrypt or other CAs</li> <li>Load Balancing Guide - Understand different load balancing algorithms and when to use them</li> <li>Production Deployment - Best practices for production deployment including systemd integration and monitoring</li> <li>Troubleshooting - Solutions to common operational issues</li> </ul> <p>For HTTP/3 and QUIC protocol details:</p> <ul> <li>HTTP/3 Overview - HTTP/3 protocol implementation and differences from HTTP/2</li> <li>QUIC Overview - QUIC transport protocol details and how Spooky uses it</li> </ul>"},{"location":"user-guide/basics/","title":"Basics","text":""},{"location":"user-guide/basics/#spooky-basics","title":"Spooky Basics","text":"<p>This guide covers fundamental concepts and basic usage of Spooky, an HTTP/3 to HTTP/2 edge proxy.</p>"},{"location":"user-guide/basics/#architecture-overview","title":"Architecture Overview","text":"<p>Spooky operates as a protocol translation layer between HTTP/3 clients and HTTP/2 backend services:</p> <ol> <li>QUIC Connection Termination: Accepts incoming HTTP/3 requests over QUIC</li> <li>Protocol Translation: Converts HTTP/3 streams to HTTP/2 requests</li> <li>Load Balancing: Routes requests to backend servers based on configured algorithms</li> <li>Response Conversion: Translates backend HTTP/2 responses back to HTTP/3</li> <li>Client Delivery: Returns responses to the client over QUIC</li> </ol> <pre><code>Client (HTTP/3/QUIC) \u2192 Spooky Edge \u2192 Backend (HTTP/2)\n                            \u2193\n                    Route Matching\n                    Load Balancing\n                    Health Checking\n</code></pre>"},{"location":"user-guide/basics/#configuration-structure","title":"Configuration Structure","text":""},{"location":"user-guide/basics/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>version: 1\n\nlisten:\n  protocol: http3\n  port: 9889\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"server.crt\"\n    key: \"server.key\"\n\nupstream:\n  default_pool:\n    load_balancing:\n      type: \"random\"\n\n    route:\n      path_prefix: \"/\"\n\n    backends:\n      - id: \"backend1\"\n        address: \"127.0.0.1:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\nlog:\n  level: info\n</code></pre>"},{"location":"user-guide/basics/#configuration-sections","title":"Configuration Sections","text":"<p>listen: Defines the edge server configuration - <code>protocol</code>: Must be \"http3\" - <code>port</code>: UDP port for QUIC connections (default: 9889) - <code>address</code>: Bind address (default: \"0.0.0.0\") - <code>tls.cert</code>: Path to TLS certificate - <code>tls.key</code>: Path to TLS private key</p> <p>upstream: Named pools of backend servers with routing rules and load balancing configuration - Key: Arbitrary pool name for identification - <code>load_balancing</code>: Load balancing algorithm for this pool (<code>random</code>, <code>round-robin</code>, <code>consistent-hash</code>) - <code>route</code>: Routing criteria to match requests - <code>backends</code>: List of backend servers</p> <p>log: Logging configuration - <code>level</code>: Log verbosity (trace, debug, info, warn, error) - <code>file.enabled</code>: Write logs to a file instead of stderr (default: false) - <code>file.path</code>: Log file path (default: <code>/var/log/spooky/spooky.log</code>)</p>"},{"location":"user-guide/basics/#upstream-pools-and-routing","title":"Upstream Pools and Routing","text":"<p>Spooky supports multiple upstream pools with independent routing rules. Requests are matched using longest-prefix matching across all configured routes.</p>"},{"location":"user-guide/basics/#path-based-routing","title":"Path-Based Routing","text":"<pre><code>upstream:\n  api_pool:\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  auth_pool:\n    route:\n      path_prefix: \"/auth\"\n    backends:\n      - id: \"auth1\"\n        address: \"10.0.2.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  default_pool:\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"web1\"\n        address: \"10.0.3.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre> <p>Routing Behavior: - Requests to <code>/api/*</code> \u2192 api_pool - Requests to <code>/auth/*</code> \u2192 auth_pool - All other requests \u2192 default_pool</p>"},{"location":"user-guide/basics/#host-based-routing","title":"Host-Based Routing","text":"<pre><code>upstream:\n  api_backend:\n    route:\n      host: \"api.example.com\"\n    backends:\n      - id: \"api1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  www_backend:\n    route:\n      host: \"www.example.com\"\n    backends:\n      - id: \"web1\"\n        address: \"10.0.2.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre>"},{"location":"user-guide/basics/#combined-routing","title":"Combined Routing","text":"<pre><code>upstream:\n  api_v2:\n    route:\n      host: \"api.example.com\"\n      path_prefix: \"/v2\"\n    backends:\n      - id: \"api-v2-1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre> <p>Matches requests to <code>api.example.com/v2/*</code>.</p>"},{"location":"user-guide/basics/#backend-configuration","title":"Backend Configuration","text":""},{"location":"user-guide/basics/#backend-parameters","title":"Backend Parameters","text":"<pre><code>backends:\n  - id: \"backend1\"              # Unique identifier\n    address: \"127.0.0.1:8080\"   # Backend address (IP:port)\n    weight: 100                 # Relative weight for load balancing\n    health_check:\n      path: \"/health\"           # Health check endpoint\n      interval: 5000            # Check interval (milliseconds)\n      timeout_ms: 2000          # Request timeout (milliseconds)\n      failure_threshold: 3      # Consecutive failures before marking unhealthy\n      success_threshold: 2      # Consecutive successes before marking healthy\n      cooldown_ms: 5000         # Cooldown period after marking unhealthy\n</code></pre>"},{"location":"user-guide/basics/#health-check-configuration","title":"Health Check Configuration","text":"<p>interval: Time between health checks in milliseconds (default: 5000)</p> <p>timeout_ms: Maximum time to wait for health check response (default: 1000)</p> <p>failure_threshold: Number of consecutive failures required to mark backend unhealthy (default: 3)</p> <p>success_threshold: Number of consecutive successes required to mark backend healthy after being unhealthy (default: 2)</p> <p>cooldown_ms: Time to wait before attempting recovery after marking unhealthy (default: 5000)</p>"},{"location":"user-guide/basics/#health-check-implementation","title":"Health Check Implementation","text":"<p>Backend services must implement health check endpoints that return 2xx status codes when healthy:</p> <pre><code>// Node.js example\napp.get('/health', (req, res) =&gt; {\n  // Verify critical dependencies\n  if (database.isConnected() &amp;&amp; cache.isReady()) {\n    res.status(200).json({ status: 'healthy' });\n  } else {\n    res.status(503).json({ status: 'unhealthy' });\n  }\n});\n</code></pre> <pre><code># Python example\n@app.route('/health')\ndef health():\n    if check_database() and check_cache():\n        return {'status': 'healthy'}, 200\n    return {'status': 'unhealthy'}, 503\n</code></pre>"},{"location":"user-guide/basics/#command-line-interface","title":"Command Line Interface","text":""},{"location":"user-guide/basics/#starting-spooky","title":"Starting Spooky","text":"<pre><code># Start with configuration file\nspooky --config config.yaml\n\n# Display version\nspooky --version\n</code></pre>"},{"location":"user-guide/basics/#command-line-options","title":"Command Line Options","text":"Option Description Default <code>--config</code> Path to configuration file Required <code>--version</code> Display version information - <code>--help</code> Display help information - <p>Note: Log level is configured in <code>config.yaml</code> (<code>log.level</code>) or via <code>RUST_LOG</code> environment variable. Configuration validation happens automatically during startup.</p>"},{"location":"user-guide/basics/#testing-and-verification","title":"Testing and Verification","text":""},{"location":"user-guide/basics/#testing-with-curl","title":"Testing with curl","text":"<p>Requires curl built with HTTP/3 support (nghttp3 and ngtcp2):</p> <pre><code># Basic HTTP/3 request\ncurl --http3-only -k https://localhost:9889/\n\n# Test with custom host resolution\ncurl --http3-only -k \\\n  --resolve example.com:9889:127.0.0.1 \\\n  https://example.com:9889/api/users\n\n# Test with headers\ncurl --http3-only -k \\\n  -H \"Authorization: Bearer token\" \\\n  https://localhost:9889/protected\n\n# Verbose output for debugging\ncurl --http3-only -k -v https://localhost:9889/\n</code></pre>"},{"location":"user-guide/basics/#load-balancing-verification","title":"Load Balancing Verification","text":"<pre><code># Generate concurrent requests\nfor i in {1..20}; do\n  curl --http3-only -k https://localhost:9889/ &amp;\ndone\nwait\n\n# Monitor backend request distribution (systemd)\nsudo journalctl -u spooky.service | grep \"routing to backend\" | \\\n  awk '{print $NF}' | sort | uniq -c\n\n# Monitor backend request distribution (if redirected to file)\ngrep \"routing to backend\" /var/log/spooky/spooky.log | \\\n  awk '{print $NF}' | sort | uniq -c\n</code></pre>"},{"location":"user-guide/basics/#health-check-monitoring","title":"Health Check Monitoring","text":"<pre><code># Monitor health check activity (systemd)\nsudo journalctl -u spooky.service -f | grep -i health\n\n# Monitor health check activity (direct process)\nspooky --config config.yaml 2&gt;&amp;1 | grep -i health\n\n# Check backend status (systemd)\nsudo journalctl -u spooky.service | grep \"backend.*healthy\" | tail -20\n\n# Check backend status (if redirected to file)\ngrep \"backend.*healthy\" /var/log/spooky/spooky.log | tail -20\n</code></pre>"},{"location":"user-guide/basics/#logging","title":"Logging","text":""},{"location":"user-guide/basics/#log-levels","title":"Log Levels","text":"Level Description Use Case <code>trace</code> Extremely verbose, includes protocol details Protocol debugging <code>debug</code> Detailed operational information Development, troubleshooting <code>info</code> General operational messages Production (default) <code>warn</code> Warning conditions Production <code>error</code> Error conditions Production"},{"location":"user-guide/basics/#log-configuration","title":"Log Configuration","text":"<pre><code># stderr (default)\nlog:\n  level: info\n\n# write to file\nlog:\n  level: info\n  file:\n    enabled: true\n    path: /var/log/spooky/spooky.log\n</code></pre>"},{"location":"user-guide/basics/#log-analysis","title":"Log Analysis","text":"<p>systemd (log.file.enabled: false)</p> <pre><code># Follow logs in real-time\nsudo journalctl -u spooky.service -f\n\n# Filter by severity\nsudo journalctl -u spooky.service | grep ERROR\n\n# Search for specific requests\nsudo journalctl -u spooky.service | grep \"GET /api/users\"\n\n# Monitor backend selection\nsudo journalctl -u spooky.service | grep \"routing to backend\"\n\n# Track health check failures\nsudo journalctl -u spooky.service | grep \"health check failed\"\n</code></pre> <p>File (log.file.enabled: true)</p> <pre><code># Follow logs in real-time\ntail -f /var/log/spooky/spooky.log\n\n# Filter by severity\ngrep ERROR /var/log/spooky/spooky.log\n\n# Search for specific requests\ngrep \"GET /api/users\" /var/log/spooky/spooky.log\n\n# Monitor backend selection\ngrep \"routing to backend\" /var/log/spooky/spooky.log\n\n# Track health check failures\ngrep \"health check failed\" /var/log/spooky/spooky.log\n</code></pre>"},{"location":"user-guide/basics/#common-deployment-patterns","title":"Common Deployment Patterns","text":""},{"location":"user-guide/basics/#development-setup","title":"Development Setup","text":"<pre><code># Generate self-signed certificate\nopenssl req -x509 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt \\\n  -days 365 -nodes -subj \"/CN=localhost\"\n\n# Create development configuration\ncat &gt; dev-config.yaml &lt;&lt;EOF\nversion: 1\n\nlisten:\n  protocol: http3\n  port: 9889\n  address: \"127.0.0.1\"\n  tls:\n    cert: \"server.crt\"\n    key: \"server.key\"\n\nupstream:\n  dev_pool:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"dev-backend\"\n        address: \"127.0.0.1:3000\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\nlog:\n  level: debug\nEOF\n\n# Start Spooky\nspooky --config dev-config.yaml\n</code></pre>"},{"location":"user-guide/basics/#example-multi-backend-setup","title":"Example Multi-Backend Setup","text":"<p>Note: Spooky is experimental. The configuration below shows how a multi-backend setup would look, but is not a production deployment recommendation.</p> <pre><code># Obtain certificates (Let's Encrypt)\ncertbot certonly --standalone -d example.com\n\n# Create production configuration\ncat &gt; prod-config.yaml &lt;&lt;EOF\nversion: 1\n\nlisten:\n  protocol: http3\n  port: 443\n  address: \"0.0.0.0\"\n  tls:\n    cert: \"/etc/letsencrypt/live/example.com/fullchain.pem\"\n    key: \"/etc/letsencrypt/live/example.com/privkey.pem\"\n\nupstream:\n  prod_pool:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"web-01\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 10000\n          timeout_ms: 3000\n          failure_threshold: 3\n          success_threshold: 2\n          cooldown_ms: 30000\n      - id: \"web-02\"\n        address: \"10.0.1.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 10000\n          timeout_ms: 3000\n          failure_threshold: 3\n          success_threshold: 2\n          cooldown_ms: 30000\n\nlog:\n  level: info\nEOF\n\n# Deploy as systemd service\nsudo systemctl start spooky\nsudo systemctl enable spooky\n</code></pre>"},{"location":"user-guide/basics/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/basics/#connection-issues","title":"Connection Issues","text":"<pre><code># Verify Spooky is listening on UDP\nsudo netstat -uln | grep 9889\n# or\nsudo ss -uln | grep 9889\n\n# Check firewall configuration\nsudo ufw status\nsudo iptables -L -n -v | grep 9889\n\n# Test UDP connectivity\nnc -u -v -z localhost 9889\n\n# Verify TLS certificate\nopenssl s_client -connect localhost:9889 -showcerts\n</code></pre>"},{"location":"user-guide/basics/#backend-connectivity","title":"Backend Connectivity","text":"<pre><code># Test backend directly\ncurl -v http://127.0.0.1:8080/health\n\n# Test through Spooky\ncurl --http3-only -k -v https://localhost:9889/health\n\n# Check backend reachability from Spooky host\ntelnet 10.0.1.10 8080\n</code></pre>"},{"location":"user-guide/basics/#configuration-validation","title":"Configuration Validation","text":"<pre><code># Validate configuration syntax (startup validation happens before serving)\nspooky --config config.yaml\n\n# Check for YAML syntax errors\nyamllint config.yaml\n\n# Verify routing configuration\ngrep -A 10 \"route:\" config.yaml\n</code></pre>"},{"location":"user-guide/basics/#performance-debugging","title":"Performance Debugging","text":"<pre><code># Monitor system resources\ntop -p $(pgrep spooky)\nhtop -p $(pgrep spooky)\n\n# Check UDP buffer statistics\nnetstat -su | grep Udp\n\n# Monitor QUIC connections\nss -u -a | grep 9889\n\n# Check for packet loss\nnetstat -s | grep -i lost\n</code></pre>"},{"location":"user-guide/basics/#next-steps","title":"Next Steps","text":"<ul> <li>Review Load Balancing for detailed algorithm documentation</li> <li>Refer to Configuration Reference for complete parameter documentation</li> <li>See Deployment Guide for production deployment best practices</li> </ul>"},{"location":"user-guide/load-balancing/","title":"Load Balancing","text":""},{"location":"user-guide/load-balancing/#load-balancing","title":"Load Balancing","text":"<p>Comprehensive guide to load balancing algorithms, health checking, and backend management in Spooky.</p>"},{"location":"user-guide/load-balancing/#load-balancing-algorithms","title":"Load Balancing Algorithms","text":"<p>Spooky implements three load balancing algorithms, each optimized for different use cases. Each upstream pool configures its own algorithm independently via <code>load_balancing.type</code>.</p>"},{"location":"user-guide/load-balancing/#round-robin","title":"Round Robin","text":"<p>Algorithm: Sequential distribution across healthy backends in a circular pattern.</p> <p>Configuration: </p><pre><code>upstream:\n  api_pool:\n    load_balancing:\n      type: \"round-robin\"  # Accepts: round-robin, round_robin, rr\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"backend1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n      - id: \"backend2\"\n        address: \"10.0.1.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre><p></p> <p>Characteristics: - Sequential, predictable distribution pattern - State maintained across requests (counter increments per request) - Equal distribution when all backends have equal weight - Automatically skips unhealthy backends - Counter wraps on overflow (no reset on restart)</p> <p>Use Cases: - Stateless applications requiring even distribution - Backends with equal capacity and performance - Scenarios where predictable patterns are acceptable - General purpose load balancing</p> <p>Performance: Very low overhead (simple counter increment)</p>"},{"location":"user-guide/load-balancing/#consistent-hashing","title":"Consistent Hashing","text":"<p>Algorithm: Hash-based routing using a consistent hash ring with virtual nodes.</p> <p>Configuration: </p><pre><code>upstream:\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"  # Accepts: consistent-hash, consistent_hash, ch\n      # key: \"header:x-user-id\"  # Planned feature: configurable hash key source\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"backend1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n      - id: \"backend2\"\n        address: \"10.0.1.11:8080\"\n        weight: 200  # 2x virtual nodes = 2x traffic share\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre><p></p> <p>Characteristics: - Deterministic routing based on hash key - Same key always routes to same backend (session affinity) - Uses 64 virtual replicas per backend per weight unit - Minimal request redistribution when backends change - FNV-1a hash function for distribution - Automatically skips unhealthy backends</p> <p>Hash Key Sources:</p> <p>Currently, the key parameter is configured but hash key extraction must be implemented in the proxy layer. The algorithm accepts any string key.</p> <pre><code># Current behavior: fixed key derivation from request\nload_balancing:\n  type: \"consistent-hash\"\n# Planned configurable key sources (not currently implemented):\n# key: \"header:x-user-id\"       # User ID from header\n# key: \"header:x-session-id\"    # Session ID from header\n# key: \"cookie:session_id\"      # Session cookie\n# key: \"query:user_id\"          # Query parameter\n# key: \"path\"                   # Request path\n</code></pre> <p>Use Cases: - Applications requiring session affinity - Cache locality optimization (same keys hit same backend caches) - Stateful applications without external session store - Minimizing cache misses during backend changes</p> <p>Performance: Low overhead (hash computation + BTreeMap lookup)</p>"},{"location":"user-guide/load-balancing/#random","title":"Random","text":"<p>Algorithm: Random selection from healthy backends.</p> <p>Configuration: </p><pre><code>upstream:\n  api_pool:\n    load_balancing:\n      type: \"random\"\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"backend1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n      - id: \"backend2\"\n        address: \"10.0.1.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre><p></p> <p>Characteristics: - Non-deterministic selection using thread-local RNG - No state maintained between requests - Statistically even distribution over time - No session affinity - Automatically skips unhealthy backends</p> <p>Use Cases: - Stateless applications - High-throughput scenarios where simplicity matters - Testing and development - Avoiding predictable patterns for security</p> <p>Performance: Very low overhead (random number generation)</p>"},{"location":"user-guide/load-balancing/#algorithm-comparison","title":"Algorithm Comparison","text":"Algorithm Complexity Session Affinity State Distribution Use Case Round Robin O(1) No Counter Even General purpose, predictable load Consistent Hash O(log n) Yes Hash ring Even (with weight) Session affinity, cache locality Random O(1) No None Statistically even Stateless, high throughput"},{"location":"user-guide/load-balancing/#backend-weighting","title":"Backend Weighting","text":"<p>Only consistent hashing respects backend weights. Round-robin and random algorithms currently ignore weights (weighted versions are planned for future release).</p>"},{"location":"user-guide/load-balancing/#weight-configuration","title":"Weight Configuration","text":"<pre><code>backends:\n  - id: \"small-instance\"\n    address: \"10.0.1.10:8080\"\n    weight: 50      # Receives 1x traffic\n    health_check:\n      path: \"/health\"\n      interval: 5000\n\n  - id: \"medium-instance\"\n    address: \"10.0.1.11:8080\"\n    weight: 100     # Receives 2x traffic (2x the first)\n    health_check:\n      path: \"/health\"\n      interval: 5000\n\n  - id: \"large-instance\"\n    address: \"10.0.1.12:8080\"\n    weight: 200     # Receives 4x traffic (4x the first)\n    health_check:\n      path: \"/health\"\n      interval: 5000\n</code></pre> <p>Weight Behavior: - Round Robin: Weight values are currently ignored (weighted round-robin planned for future release) - Consistent Hash: Number of virtual nodes = replicas \u00d7 weight (64 replicas per weight unit) - Random: Weight values are currently ignored (weighted random planned for future release) - Minimum: Weight values below 1 are clamped to 1</p>"},{"location":"user-guide/load-balancing/#health-checking","title":"Health Checking","text":"<p>Spooky performs active health checks on all backends. Unhealthy backends are automatically removed from rotation.</p>"},{"location":"user-guide/load-balancing/#health-check-mechanism","title":"Health Check Mechanism","text":"<pre><code>backends:\n  - id: \"backend1\"\n    address: \"10.0.1.10:8080\"\n    weight: 100\n    health_check:\n      path: \"/health\"              # Health check endpoint path\n      interval: 5000               # Check every 5 seconds\n      timeout_ms: 2000             # 2 second timeout per check\n      failure_threshold: 3         # 3 failures \u2192 mark unhealthy\n      success_threshold: 2         # 2 successes \u2192 mark healthy\n      cooldown_ms: 10000           # 10 second cooldown before recovery\n</code></pre>"},{"location":"user-guide/load-balancing/#health-check-parameters","title":"Health Check Parameters","text":"<p>path: Endpoint to check (default: \"/health\") - Must return 2xx status code when healthy - Should be lightweight and fast</p> <p>interval: Time between checks in milliseconds (default: 5000) - Lower values = faster failure detection - Higher values = lower overhead</p> <p>timeout_ms: Maximum wait time for response (default: 1000) - Should be less than interval - Failed on timeout</p> <p>failure_threshold: Consecutive failures to mark unhealthy (default: 3) - Higher values = more tolerance for transient failures - Lower values = faster failure detection</p> <p>success_threshold: Consecutive successes to mark healthy (default: 2) - Higher values = more confidence before recovery - Lower values = faster recovery</p> <p>cooldown_ms: Minimum time to stay unhealthy (default: 5000) - Prevents flapping - Gives backend time to recover</p>"},{"location":"user-guide/load-balancing/#health-state-machine","title":"Health State Machine","text":"<pre><code>Initial State: Healthy\n              |\n              | failure_threshold consecutive failures\n              v\n         Unhealthy (cooldown period)\n              |\n              | cooldown expires\n              v\n         Unhealthy (testing)\n              |\n              | success_threshold consecutive successes\n              v\n           Healthy\n</code></pre> <p>Healthy: Backend receives traffic, failures are counted</p> <p>Unhealthy (cooldown): Backend removed from rotation, health checks continue but successes are ignored until cooldown expires</p> <p>Unhealthy (testing): Backend still removed from rotation, consecutive successes are counted toward success_threshold</p>"},{"location":"user-guide/load-balancing/#backend-state-tracking","title":"Backend State Tracking","text":"<p>The load balancer tracks per-backend state:</p> <pre><code>struct BackendState {\n    address: String,\n    weight: u32,\n    health_check: HealthCheck,\n    consecutive_failures: u32,\n    health_state: HealthState,  // Healthy | Unhealthy { until, successes }\n}\n</code></pre> <p>State transitions: - record_success(): Increments success counter, transitions to Healthy if threshold met - record_failure(): Increments failure counter, transitions to Unhealthy if threshold met</p>"},{"location":"user-guide/load-balancing/#multiple-upstream-pools","title":"Multiple Upstream Pools","text":"<p>Spooky supports multiple upstream pools with independent routing and load balancing configuration. Each pool specifies its own algorithm.</p>"},{"location":"user-guide/load-balancing/#configuration-example","title":"Configuration Example","text":"<pre><code>upstream:\n  api_pool:\n    load_balancing:\n      type: \"consistent-hash\"  # Session affinity for API requests\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api1\"\n        address: \"10.0.1.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n      - id: \"api2\"\n        address: \"10.0.1.11:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  auth_pool:\n    load_balancing:\n      type: \"round-robin\"  # Even spread across auth backends\n    route:\n      path_prefix: \"/auth\"\n    backends:\n      - id: \"auth1\"\n        address: \"10.0.2.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n  static_pool:\n    load_balancing:\n      type: \"random\"  # Stateless static assets, any backend is fine\n    route:\n      path_prefix: \"/static\"\n    backends:\n      - id: \"cdn1\"\n        address: \"10.0.3.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 10000\n</code></pre> <p>Route Matching: - Routes are evaluated by longest-prefix matching - Route with most specific (longest) path prefix wins - For equal-length prefixes, selection depends on HashMap iteration order - Important: Unmatched routes return an error - configure a catch-all upstream (e.g., <code>path_prefix: \"/\"</code>) to handle all other requests</p>"},{"location":"user-guide/load-balancing/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"user-guide/load-balancing/#logging","title":"Logging","text":"<p>Health check events are logged:</p> <pre><code>[INFO] Backend backend1 health check passed\n[WARN] Backend backend2 health check failed: connection timeout\n[INFO] Backend backend2 marked unhealthy after 3 consecutive failures\n[INFO] Backend backend2 marked healthy after 2 consecutive successes\n[DEBUG] Routing request to backend backend1 (round-robin)\n[DEBUG] Routing request to backend backend2 (consistent-hash, key=user:123)\n</code></pre>"},{"location":"user-guide/load-balancing/#health-check-monitoring","title":"Health Check Monitoring","text":"<pre><code># Monitor health check activity (systemd)\nsudo journalctl -u spooky.service -f | grep -i health\n\n# Monitor health check activity (direct process)\nspooky --config config.yaml 2&gt;&amp;1 | grep -i health\n\n# Count backend state changes (systemd)\nsudo journalctl -u spooky.service | grep \"marked unhealthy\\|marked healthy\" | tail -20\n\n# Count backend state changes (if redirected to file)\ngrep \"marked unhealthy\\|marked healthy\" /var/log/spooky/spooky.log | tail -20\n\n# Track specific backend (systemd)\nsudo journalctl -u spooky.service | grep \"backend1\" | grep health\n\n# Track specific backend (if redirected to file)\ngrep \"backend1\" /var/log/spooky/spooky.log | grep health\n</code></pre>"},{"location":"user-guide/load-balancing/#load-distribution-analysis","title":"Load Distribution Analysis","text":"<pre><code># Extract backend selection counts (systemd)\nsudo journalctl -u spooky.service | grep \"routing to backend\" | \\\n  awk '{print $NF}' | sort | uniq -c | sort -rn\n\n# Monitor routing decisions in real-time (systemd)\nsudo journalctl -u spooky.service -f | grep \"routing to backend\"\n\n# If redirected to file\ngrep \"routing to backend\" /var/log/spooky/spooky.log | \\\n  awk '{print $NF}' | sort | uniq -c | sort -rn\n</code></pre>"},{"location":"user-guide/load-balancing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/load-balancing/#algorithm-performance","title":"Algorithm Performance","text":"Algorithm Time Complexity Memory per Backend Per-Request Cost Round Robin O(1) ~8 bytes Counter increment Consistent Hash O(log n) ~4 KB (64 replicas \u00d7 weight) Hash + BTreeMap lookup Random O(1) ~0 bytes RNG call <p>n = number of healthy backends</p>"},{"location":"user-guide/load-balancing/#backend-pool-operations","title":"Backend Pool Operations","text":"<pre><code>// All operations filter to healthy backends first\nhealthy_indices()              // O(n) - scans all backends\npick_backend(algorithm)        // O(1) or O(log n) depending on algorithm\nmark_success(index)            // O(1) - direct index access\nmark_failure(index)            // O(1) - direct index access\n</code></pre>"},{"location":"user-guide/load-balancing/#scalability","title":"Scalability","text":"<ul> <li>Backend Count: Algorithms scale to hundreds of backends</li> <li>Health Checks: Run asynchronously, do not block request path</li> <li>Memory: ~8-12 KB per backend (including health state and hash ring)</li> <li>CPU: Minimal overhead for all algorithms</li> </ul>"},{"location":"user-guide/load-balancing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/load-balancing/#uneven-load-distribution","title":"Uneven Load Distribution","text":"<p>Symptoms: Some backends receive disproportionate traffic</p> <p>Diagnosis: </p><pre><code># Check backend weights\ngrep -A 10 \"backends:\" config.yaml | grep -E \"id|weight\"\n\n# Monitor actual distribution (systemd)\nsudo journalctl -u spooky.service | grep \"routing to backend\" | \\\n  awk '{print $NF}' | sort | uniq -c\n\n# If redirected to file\ngrep \"routing to backend\" /var/log/spooky/spooky.log | \\\n  awk '{print $NF}' | sort | uniq -c\n\n# Verify all backends are healthy (systemd)\nsudo journalctl -u spooky.service | grep \"healthy\" | tail -20\n\n# If redirected to file\ngrep \"healthy\" /var/log/spooky/spooky.log | tail -20\n</code></pre><p></p> <p>Solutions: - Verify backend weights are configured correctly - Check for unhealthy backends (temporarily removed from rotation) - For consistent-hash, verify hash keys are well-distributed - For round-robin, ensure sufficient request volume for even distribution</p>"},{"location":"user-guide/load-balancing/#session-affinity-not-working","title":"Session Affinity Not Working","text":"<p>Symptoms: Requests from same user/session hit different backends</p> <p>Diagnosis: </p><pre><code># Verify consistent-hash configuration\ngrep -A 5 \"load_balancing:\" config.yaml | grep -E \"type|key\"\n\n# Check if hash key is present in requests (systemd)\nsudo journalctl -u spooky.service -f | grep \"consistent-hash\"\n\n# Check if hash key is present in requests (if redirected to file)\ntail -f /var/log/spooky/spooky.log | grep \"consistent-hash\"\n\n# Test with known hash key\ncurl --http3-only -H \"X-User-ID: test123\" https://localhost:9889/\n</code></pre><p></p> <p>Solutions: - Ensure load_balancing.type is \"consistent-hash\" - Note: Hash key is automatically derived from request (authority \u2192 path \u2192 method) - For session affinity, ensure requests include consistent authority or path components - Configurable key sources are planned for future implementation</p>"},{"location":"user-guide/load-balancing/#frequent-health-check-failures","title":"Frequent Health Check Failures","text":"<p>Symptoms: Backends repeatedly marked unhealthy despite being functional</p> <p>Diagnosis: </p><pre><code># Monitor health check failures (systemd)\nsudo journalctl -u spooky.service -f | grep \"health check failed\"\n\n# If redirected to file\ntail -f /var/log/spooky/spooky.log | grep \"health check failed\"\n\n# Test health endpoint directly\ncurl -v http://10.0.1.10:8080/health\n\n# Check response time\ntime curl http://10.0.1.10:8080/health\n\n# Verify network connectivity\nping 10.0.1.10\ntraceroute 10.0.1.10\n</code></pre><p></p> <p>Solutions: - Increase health check timeout (timeout_ms) if endpoint is slow - Increase failure_threshold to tolerate transient failures - Optimize backend health endpoint performance - Check network latency and packet loss - Verify health check path is correct</p>"},{"location":"user-guide/load-balancing/#backends-not-recovering","title":"Backends Not Recovering","text":"<p>Symptoms: Healthy backends remain marked unhealthy</p> <p>Diagnosis: </p><pre><code># Check cooldown period\ngrep -A 10 \"health_check:\" config.yaml | grep cooldown_ms\n\n# Monitor recovery attempts (systemd)\nsudo journalctl -u spooky.service -f | grep -E \"marked healthy|success\"\n\n# If redirected to file\ntail -f /var/log/spooky/spooky.log | grep -E \"marked healthy|success\"\n\n# Verify backend is actually healthy\ncurl http://10.0.1.10:8080/health\n</code></pre><p></p> <p>Solutions: - Reduce cooldown_ms for faster recovery - Reduce success_threshold if being too conservative - Verify backend health endpoint returns 2xx status - Check for health check timeout issues</p>"},{"location":"user-guide/load-balancing/#no-backends-available","title":"No Backends Available","text":"<p>Symptoms: All backends marked unhealthy, requests fail</p> <p>Diagnosis: </p><pre><code># List all backend states (systemd)\nsudo journalctl -u spooky.service | grep -i \"backend.*health\" | tail -20\n\n# If redirected to file\ngrep -i \"backend.*health\" /var/log/spooky/spooky.log | tail -20\n\n# Check configuration\ngrep -A 15 \"backends:\" config.yaml\n\n# Test each backend directly\nfor backend in 10.0.1.10:8080 10.0.1.11:8080; do\n  echo \"Testing $backend\"\n  curl -v http://$backend/health\ndone\n</code></pre><p></p> <p>Solutions: - Fix backend health endpoints - Adjust health check parameters (increase timeout, threshold) - Verify backends are actually running and accessible - Check firewall rules between Spooky and backends</p>"},{"location":"user-guide/load-balancing/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/load-balancing/#health-check-configuration","title":"Health Check Configuration","text":"<ul> <li>Set timeout_ms &lt; interval to prevent check pileup</li> <li>Use failure_threshold \u2265 3 to avoid false positives</li> <li>Set cooldown_ms \u2265 10000 to prevent flapping</li> <li>Keep health endpoints lightweight (&lt; 100ms response time)</li> </ul>"},{"location":"user-guide/load-balancing/#algorithm-selection","title":"Algorithm Selection","text":"<ul> <li>Use Round Robin for simple, even distribution with equal backends</li> <li>Use Consistent Hash when session affinity or cache locality matters</li> <li>Use Random for stateless, high-throughput scenarios</li> </ul>"},{"location":"user-guide/load-balancing/#weight-configuration_1","title":"Weight Configuration","text":"<ul> <li>Base weights on backend capacity (CPU, memory, network)</li> <li>Start with equal weights, adjust based on monitoring</li> <li>Use relative weights (100, 200, 400) rather than absolute</li> <li>For consistent-hash, remember: weight \u00d7 64 = number of virtual nodes</li> </ul>"},{"location":"user-guide/load-balancing/#upstream-pool-design","title":"Upstream Pool Design","text":"<ul> <li>Create separate pools for different services (API, auth, static)</li> <li>Order routes from most specific to least specific</li> <li>Use path_prefix for path-based routing</li> <li>Use host for virtual host routing</li> <li>Provide a catch-all default pool</li> </ul>"},{"location":"user-guide/load-balancing/#advanced-configuration-examples","title":"Advanced Configuration Examples","text":""},{"location":"user-guide/load-balancing/#multi-tier-application","title":"Multi-Tier Application","text":"<pre><code># Global load balancing strategy (applies to all upstream pools)\n# Per-upstream load_balancing is planned but not currently active\nload_balancing:\n  type: \"round-robin\"\n\nupstream:\n  api_tier:\n    route:\n      path_prefix: \"/api\"\n    backends:\n      - id: \"api1\"\n        address: \"10.0.1.10:8080\"\n        weight: 200\n        health_check:\n          path: \"/health\"\n          interval: 5000\n          timeout_ms: 2000\n          failure_threshold: 3\n          success_threshold: 2\n          cooldown_ms: 15000\n\n  auth_tier:\n    route:\n      path_prefix: \"/auth\"\n    backends:\n      - id: \"auth1\"\n        address: \"10.0.2.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 3000\n          timeout_ms: 1000\n          failure_threshold: 2\n          success_threshold: 2\n          cooldown_ms: 10000\n\n  static_tier:\n    route:\n      path_prefix: \"/static\"\n    backends:\n      - id: \"cdn1\"\n        address: \"10.0.3.10:8080\"\n        weight: 100\n        health_check:\n          path: \"/health\"\n          interval: 30000\n          timeout_ms: 5000\n          failure_threshold: 5\n          success_threshold: 1\n          cooldown_ms: 60000\n</code></pre>"},{"location":"user-guide/load-balancing/#heterogeneous-backend-capacities","title":"Heterogeneous Backend Capacities","text":"<pre><code>upstream:\n  prod_pool:\n    load_balancing:\n      type: \"round-robin\"\n    route:\n      path_prefix: \"/\"\n    backends:\n      - id: \"small-1\"\n        address: \"10.0.1.10:8080\"\n        weight: 50       # 2 vCPU, 4 GB RAM\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n      - id: \"medium-1\"\n        address: \"10.0.1.11:8080\"\n        weight: 100      # 4 vCPU, 8 GB RAM\n        health_check:\n          path: \"/health\"\n          interval: 5000\n\n      - id: \"large-1\"\n        address: \"10.0.1.12:8080\"\n        weight: 200      # 8 vCPU, 16 GB RAM\n        health_check:\n          path: \"/health\"\n          interval: 5000\n</code></pre>"},{"location":"user-guide/load-balancing/#related-documentation","title":"Related Documentation","text":"<ul> <li>See Basics for general configuration and deployment</li> <li>Refer to Configuration Reference for complete parameter documentation</li> <li>See Architecture Guide for internal implementation details</li> </ul>"}]}